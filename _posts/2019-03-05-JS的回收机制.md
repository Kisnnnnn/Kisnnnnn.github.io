---
layout: post
title:  "2019-03-05-JS的回收机制"
date:   2019-03-05 21:00:00 +0800
categories: 前端
tag: 笔记
---

* content
{:toc}




## 回收机制
> JS为了防止内存泄露，会执行回收机制
### 什么是内存泄漏？
当已经不需要某块内存时，内存却还存在。

所以，回收机制就是阶段性的不定期去寻找不再使用的变量，并释放他们所指向的内存

比如如何处理哪些已经执行完毕的函数，如果么有外部应用，则会回收。

常用的两种垃圾回收规则：
- 标记清除
- 引用计数

Javascript引擎基础GC方案是（Simple GC）：

**mark and sweep** —> 标记清楚

- 遍历所以可访问的对象
- 回收已不可访问的对象
比如：
```
当变量进入环境时，例如，在函数中声明一个变量，就将它标记为「进入环境」
从逻辑上来讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用他它们。
而当变量离开环境的时候，则会标记「离开环境」
垃圾回收机在运行的时候会给存储在内存中的所有边浪都加上标记
然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）
而在此之后再被加上标记的变量会将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了
最后垃圾回收期完成内存清除工作，销毁哪些带标记的值，并回收他们所占用的内存空间
```

简单的阐述：

跟踪记录每个值被引用的次数，当一个值被引用时，次数-1，减持时-1，下次垃圾回收器会收回次数为0的值的内存。

### GC的缺陷

出于安全考虑**GC时，停止响应其他操作**
但是它操作时候在**100ms**甚至以上

对于一般应用还可以，但是对于js游戏，动画对连贯性要求比较高的应用，需要另外处理。

### GC的优化策略

#### 分带回收（Generation GC）
目的是通过区分「临时」与「持久」对象:
- 多回收「临时对象」区（young generation）
- 少回收「持久对象」区（tenured generation）
- 减少每次需遍历的对象，从而减少每次GC的耗时。


## 结语

「从输入url到页面渲染」文章已经整理（抄）完了，面对如此复杂的机制，很多地方依旧不理解，明天开始准备从基础慢慢开始学习。
