<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[手动实现apply-call-bind]]></title>
    <url>%2F2019%2F08%2F20%2F2019-08-20-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0apply-call-bind%2F</url>
    <content type="text"><![CDATA[--- title: 手动实现apply-call-bind date: 2019-08-20 21:00:00 +0800 categories: 前端 tag: 笔记 --- ### apply ```js Function.prototype.myApply = function(context,args){ // 如果是调用自己，则返回undefined if(this===Function.prototype) return false; context=context || window; var fn = Symbol(), result; context[fn]=this; if(Array.isarray(args)){ result = context[fn](...args); }else{ result = context[fn](); } delete context[fn]; return result; } ``` 1.如果是调用自己，则返回undefined 2.判断`context`是否存在，不存在则调用window 3.新增一个`Symbol`属性，赋值给`context` 4.将当前函数赋值给这个属性 5.判断传参是否数组 6.如果是，则将其余的参数传入执行方法。如果否，则直接调用方法。 7.删除方法，返回。 ### call ```js Function.prototype.myCall= function(context=window,...args){ if(this === Function.prototype) return undefined; context= context || window var fn = Symbol(), result; context[fn] = this; result = context[fn](...args) delete context[fn] return result; } ``` 1.如果是调用自己，则返回undefined 2.判断`context`是否存在，不存在则调用window 3.新增一个`Symbol`属性，赋值给`context` 4.将当前函数赋值给这个属性 5.将其余的参数传入执行方法 6.删除方法，返回。 ### bind ```js Function.prototype.myBind = function(context=window,...args){ if(this === Function.prototype) return undefined; const _this = this ; return function F(...args2){ if(this instanceof F){ return new _this(...args,...args2) } _this.apply(context,args.concat(...args2)) } } ``` 1.处理参数，返回一个闭包 2.判断是否为构造函数调用，如果是则调用`new`调用当前函数 3.如果不是，则用`apply`，将`context`和`args`参数传入 [参考](http://www.conardli.top/docs/JavaScript/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0call%E3%80%81apply%E3%80%81bind.html#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0apply)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise构造函数和then方法的执行顺序]]></title>
    <url>%2F2019%2F08%2F14%2F2019-08-14-Promise%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8Cthen%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[--- title: Promise构造函数和then方法的执行顺序 date: 2019-08-14 21:00:00 +0800 categories: 前端 tag: 笔记 --- ## Promise的基本用法 ```js let promise = new Promise((resolve, reject) => { console.log(1) // 如果执行失败，则调用reject() // reject('fail') console.log(2) // 如果执行成功，则调用resolve() resolve('success') }) // 如果执行成功，则继续调用then方法 promise.then(res => { // console.log(res) console.log(3) }) // 如果执行失败，则用catach捕获失败 promise.catch(err => { console.log(err) console.log(4) }) ``` 在`Promise`的内部，执行顺序是同步的。其次等内部执行完成后，调用再选择调用`then`or`catch`方法。 所以这次输出的结果： > 1 2 3 ## then的执行顺序 ```js let promise = new Promise((resolve, reject) => { console.log(1) // 如果执行失败，则调用reject() // reject('fail') console.log(2) // 如果执行成功，则调用resolve() resolve('success') }) // 如果执行成功，则继续调用then方法 promise.then(res => { console.log(res) console.log(3) }) // promise内部是同步的，但是then方法是异步的 console.log(5) ``` `then`方法执行是异步的，不用等到`then`的方法结果,会直接执行`console.log(5)` > 1 2 5 3 ### 我们可以根据上面的代码，丰富业务实际情况 ```js let promise = new Promise((resolve, reject) => { console.log(`开始执行`) // 如果执行成功，则调用resolve() resolve('success') console.log(`执行中ing`) }).then(res => { console.log(res) console.log('执行成功，继续执行下一步') return '第二then方法，开始' }) // 如果执行成功，则继续调用then方法 promise.then(res => { console.log(res) }) // promise内部是同步的，但是then方法是异步的 console.log(`我会在then方法前，先执行`) // 我们可以利用timeout方法在then方法执行完成后，进行执行 setTimeout(()=>console.log(`then方法执行完成后，开始执行`)) ``` #### 执行结果： > 1.开始执行 2.执行中ing 3.我会在then方法前，先执行 4.执行成功，继续执行下一步 5.第二then方法，开始 6.then方法执行完成后，开始执行 ### 总结 其实比较好理解的方式是：每次当`promise`执行完成后，`then`是异步的，所以当执行`then`后，不会等它的结果，会直接执行下面的代码，但是`setTimeout`定时器本身会将执行内容调到`任务队列`尾部，所以会等`then`方法执行完成后才会调用定时器。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-解构赋值-数组和对象]]></title>
    <url>%2F2019%2F06%2F05%2F2020-06-05-ES6%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[--- title: 'ES6-解构赋值-数组和对象' date: 2019-06-05 21:00:00 +0800 categories: 前端 tag: 笔记 --- ## 什么是解构？ 按照一定的模式从数组或者对象中取值，对变量进行赋值的过程称为「解构」 在 ES5 中，为变量赋值只能直接指定值： ``` var a=1,b=2,c=3 a; // 1 b; // 2 c; // 3 ``` 但是在 ES6 中，我们可以被允许写成： ``` var [a,b,c]=[1,2,3]; a; // 1 b; // 2 c; // 3 ``` ES6 中可以很明显看出来，我们可以在数组中取数据，按照位置的对应关系对变量赋值。 ### [默认值] > 解构赋值允许使用默认值 ``` var [foo = true] = []; foo; // true ``` ``` [x,y = 'b'] = ['a'] x; // "a" y; // "b" ``` ``` [x,y = 'b'] = ['a','c'] x; // "a" y; // "c" ``` ES6 内部使用的是严格相等运算符(===)判断一个位置是否有值。所以，如果一个数组成员不严格等于 undefind，默认值是不会生效的。 ``` var [x = 1] = [undefined]; x; // 1 ``` ``` null == undefined // true var [x = 1] = [null]; x; // null ``` 上述代码中，一个数组成员是 null,因此默认值不生效。因为 null 不严格等于 undefined。 ``` function f(){ console,log('aaa'); } let [x = f()] = [1]; // undefined ,不执行 f() x; // 1 ``` ## 对象的解构赋值 ``` var {foo,bar}={foo:"aaa",bar:"bbb"}; foo; // "aaa" bar; // "bbb" ``` 对象的解构赋值和数组有一个不同，数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 ``` var {laf} = {foo:"aaa",bar:"bbb"}; laf; // undefined; ``` 在上面代码中，变量没有对应的同名属性，导致取不到值，最后等于 undefind。 实际上，对象的解构赋值是以下形式的简写。 ``` var { foo: foo, bar: bar } = { foo:"aaa", bar:"bbb" } ``` 实际上，在对象的解构赋值的内部机制，是先找到同名属性，然后在赋值给对应的变量。真正被赋值的是后者，而不是前者。 ``` var { foo : bar } = {foo : "aaaa"}; foo; // foo is not defined bar; // "aaaa" ``` 采用这种写法是，变量的声明和赋值都是一体的。对于 let 和 const 而言，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。 ``` let foo; let {foo}={foo:'1'} // Uncaught SyntaxError: Identifier 'foo' has already been declared ``` 所以不能重复 let 声明： ``` let foo; ({foo} = {foo:1}) ``` 对象的解构也可以制定默认值。 ``` var {x,y = 5} = {x:1}; x; // 1 y; // 5 ``` 默认值生效条件是，对象属性严格不等于 undefined ``` var {x = 3} = {x: undefined}; x; // 3 var {x = 3} = {x:null}; x; // null ``` 和数组一样，解构也可以用于嵌套解构的对象。 ``` var obj={ p:[ "hello", {y:"world"} ] } ``` 这时的 p 是模式，不是变量，因此不会被赋值。如果 p 也要作为变量赋值，应该写成这样： ``` var obj = { p:{ "Hello", { y:"World" } } } let {p, p : { x , [ { y } ] = obj; x // "Hello" y // "World" p // ["Hello", {y: "World"}] ``` 下面一个例子： ``` var {loc,loc:{start},loc:{ start: { { line,column } } }={ loc:{ start:{ line:1, column:5 } } } ``` > 上面代码有三次解构赋值，分别是对 loc、start、line 三个属性的解构赋值。注意，最后一次对 line 属性的解构赋值之中，只有 line 是变量，loc 和 start 都是模式，不是变量。 ![赋值图示](http://ww2.sinaimg.cn/large/006tNc79gy1g3qcvneddpj30ik07pmxh.jpg) ``` var obj = []; var arr = []; ({foo:obj.prop,bar: arr[0]} = {foo:123,bar:true}); obj; // {prop:123} arr; // [true] ``` 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，则会报错 ``` var {foo : {bar}} = {baz:'baz'}; ``` 正确的写法： ``` var {foo,foo:{bar}}={foo:{bar:'bar'}}; ```]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue的生命周期]]></title>
    <url>%2F2019%2F06%2F04%2F2019-06-04-Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[--- title: 'Vue的生命周期' date: 2019-06-04 21:00:00 +0800 categories: 前端 tag: 笔记 --- ## 什么是生命周期？ 每个 Vue 实例在被创建时都经过了一系列的初始化过程 - 设置数据监听 - 编译模板 - 将实例挂载到 DOM - 数据变化时更新 DOM 在这一系列过程中，也会运行一些「生命周期钩子」的函数，用在给开发者在不同阶段添加自己的代码的机会。 > 「created」钩子，在一个实例被创建后执行代码 ``` new Vue({ data: { a: 1 }, created: function () { // `this` 指向 vm 实例 console.log('a is: ' + this.a) } }) // => "a is: 1" ``` > 不要在选项属性或回调上使用箭头函数，比如 created: () => console.log(this.a) 或 vm.\$watch('a', newValue => this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。 ![流程图](https://cn.vuejs.org/images/lifecycle.png) > 参考 [Vue 实例](https://cn.vuejs.org/v2/guide/instance.html#生命周期图示) 通俗的讲：就是在.Vue 从加载前到销毁后，这一些系列过程中，有特定的阶段 fn 可以提供我们开发者来进行操作。 ## 阶段 | 钩子函数方法 | 触发阶段 | 操作 | | ------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------- | | beforeCreate | 创建前 | 组件实例刚被创建，组件属性计算前，数据对象 data 都未定义，未初始化 | | created | 创建后 | 组件实例创建完成，属性已经绑定，数据对象 data 已经定义存在，DOM 没为生成，\$el 未存在 | | beforeMount | 挂载前 | Vue 实例的\$el 和 data 都已经初始化完成，挂在前为虚拟的 dom 节点，模板还没有渲染到 HTML 页面上去，data.message 未替换。 | | mounted | 挂载后 | Vue 实例挂载完成，模板已经渲染到 HTML 中，dota.message 成功渲染。这个阶段可以做一些 ajax 请求操作，mounted 在周期中只会执行一次。 | | beforeUpdate | 更新前 | 当 dota 更新之前，会触发 beforeUpdate 方法。 | | updated | 更新后 | 当 data 更新完成后，触发 updated 方法。 | | beforeDestory | 销毁前 | Vue 组件实例销毁前执行的方法。 | | destroyed | 销毁后 | 组件销毁后，调用的方法，对 data 的改变不会再触发函数周，vue 实例已经解除事件监听和 dom 绑定，但 dom 结构依然存在。 | ![图解](http://ww1.sinaimg.cn/large/006tNc79gy1g3p47s9i2qj30u01y0jwq.jpg) ### 示例 ``` import Axios from 'axios' // 这是一个轻量级的ajax库，import是es6模块导入的语法。 export default { // 这是一个vue的模块，后面讲奥。 name: 'app', components: { }, data: function () { return { list: [] } }, mounted: function () { // 挂在完成后的生命周期钩子注册。 this.$nextTick(function () { // 等待下一次更新完成后执行业务处理代码。 Axios.get('/api/menulist', {// 将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新 params: { } }).then(function (res) { this.list = res.data }.bind(this)) }) } } ``` ## Vue 实例的全局配置 - silent - 类型：boolean - 默认值：false - 用法： ``` Vue.config.silent = true // 取消Vue所有的日志与警告 ``` - optionMergeStrategies - 类型： { [key: string]: Function } - 默认值： {} - 用法： ``` Vue.config.optionMergeStrategies._my_option=function( parent,child,vm){ return child+1 } const Profile = Vue.extend({ _my_option: 1 }) Profile.options._my_option = 2 // 自定义合并策略选项 // 合并策略选项分别接受第一个参数作为父实例，第二个参数为子实例，Vue实例上下文被作为第三个参数传入。 ``` - devtools - 类型：boolean - 默认值：true - 用法： ``` // 务必在加载 Vue 之后，立即同步设置以下内容Vue.config.devtools = true // 配置是否允许 vue-devtools 检查代码。开发版本默认为 true，生产版本默认为 false。生产版本设为 true 可以启用检查。 ``` ## Vue 的全局 API - Vue.nextTick > 语法：Vue.nextTick([callback, context]) ``` {Function}[callback] {Object}[callback] ``` 用法： 在下次 DOM 更新循环结束后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM ``` // 修改数据 vm.msg = 'msg' // DOM未更新 Vue.nexTick(function() { // DOM更新了 // 执行操作 }) ``` - Vue.set > 语法：Vue.set( object, key, value) 参数: ``` {Object} object {String} key {any} value ``` 用法： 设置对象数据。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新，这个方法主要用于避开 Vue 不能检测属性被添加的限制。注意对象不能使 Vue 示例，或者 Vue 实例的根数据对象。 - Vue.complie > 语法：Vue.compile(template) 参数： ``` {string} template ``` 用法： ``` // 在render函数中编译模板字符串 // 在独立构建时有效 var res = Vue.Compile(`{{ msg }}`) new Vuew({ data:{ msg:'hello' }, render:res.render, staticRenderFns:res.staticRenderFns }) ``` 更多的 API 和用法请看-> [API-Vue](https://cn.vuejs.org/v2/api/)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express.js之路-基础]]></title>
    <url>%2F2019%2F06%2F03%2F2019-06-03-Express.js%E4%B9%8B%E8%B7%AF-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[--- title: 'Express.js之路-基础' date: 2019-06-03 21:00:00 +0800 categories: 前端 tag: 笔记 --- - content {:toc} ## 什么是 Express.js？ 它是一个基于 Node.js 平台，快速、开放、极简的 web 开发框架。 在 Express 中就是一个重点：API。这让我们更加注重业务的功能和开发效率。 ## 如何使用 Express.js ### 1.安装 ``` cd myproejct npm install express --save ``` ### 2.在项目中引入： ``` const express = require('express') // 获取sever示例 const app = express(); // 绑定服务器接收请求，并添加处理回调参数 app.get('/',(req,res) => { // 成功接收后，发起回调参数。 res.send('Hello World') }) ``` ### 3.项目运行 ``` node server.js ``` ![image](http://ww3.sinaimg.cn/large/006tNc79gy1g3npum8z2qj31hc0r776f.jpg) > 我们利用 Express 框架可以减少我们的代码量，比起之前使用的 node 核心模块 http 构建服务器代码排版更直观。Express 底层使用的是 htp 核心模块的 API。如果要处理客户端不同请求路径，我们可以往下罗列多个 ==app.get()== 方法，无需使用 ==if...else...==来判断。Express 也不用我们设置响应头的 Content-Type 和中文编码格式，会底层自动识别添加 ``` app.get('/', (req, res) => { res.send('Hello World') }) app.get('/json', (req, res) => { res.send({ app:'你好', name:'China' }) }) ``` ## Express 中的静态服务 ### 什么是静态服务？ 在一些网站后端中，我们有一些静态文件暴露出来，用户可以根据 url 地址进去访问到其中的内容，这些静态文件也往往称之为公共资源，所以我们需要利用 Expree 框架来托管静态资源 ### 如何使用 Express 托管静态文件？ 请使用 Express 中的 express.static 内置中间件函数 此函数特征： ``` express.static(root,[options]) ``` 通过下列代码就可以将 public 目录下的图片，css 文件，JavaScript 文件对外开放访问了 ``` app.use('/static/',express.static('public')); ``` 于是在制定用户必须以/static/开头的 url 地址才能访问到静态文件夹「public」下的文件。 ![静态文件夹](http://ww1.sinaimg.cn/large/006tNc79gy1g3nqmzen49j306l05n0sl.jpg) ![指定的静态访问地址](http://ww2.sinaimg.cn/large/006tNc79gy1g3nqmgplvuj30fo06v0sr.jpg) #### 注意： - 你可以部署多个静态文件目录，请多次调用该中间件函数 ``` app.use(express.static('public')) app.use(express.static('files')) ``` - 你可以不写一个参数，直接暴露根目录文件夹下静态文件 ，用户根据指定的文件地址来访问对应资源。 ``` app.use(express.static('public')) ``` ![image](http://ww4.sinaimg.cn/large/006tNc79gy1g3nqs0of8oj30ri0fa3yu.jpg)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-05-29-VUE中的$ref、$on、$emit]]></title>
    <url>%2F2019%2F05%2F29%2F2019-05-29-VUE%E4%B8%AD%E7%9A%84ref%E3%80%81on%E3%80%81emit%2F</url>
    <content type="text"><![CDATA[--- title: '2019-05-29-VUE中的$ref、$on、$emit' date: 2019-05-29 21:00:00 +0800 categories: 前端 tag: 笔记 --- ## \$emit(eventNanme,[...args]) - 参数： - {string} eventName 触发事件名字 - [...args] 附加的参数 - 用法： - 触发当前实例上的事件。附加参数都会传给监听器回调。 - 使用场景 - 子组件调用父组件的方法并且传递数据 > 注意：子组件标签中的时间也不区分大小写要用“-”隔开 子组件： ``` 点击我 export default { data() { return { msg: "我是子组件中的数据" } }, methods: { emitEvent(){ this.$emit('my-event', this.msg) //通过按钮的点击事件触发方法，然后用$emit触发一个my-event的自定义方法，传递this.msg数据。 } } } ``` 父组件： ``` import ChildA from './components/child.vue' export default { components: { ChildA }, methods: { getMyEvent(msg){ console.log('接收的数据--------->'+msg)//接收的数据--------->我是子组件中的数据 } } } ``` - 交互过程： - child.vue 为子组件，当在 child.vue，点击 button。 - 触发子组件的「emitEvent」方法 - 在 emitEvent 方法中执行「this.\$emit)('my-event',this.msg)」,调用父组件的「my-event」的方法 - 执行「getMyEvent」方法 实际上就是在子组件上操作，但是作用在父组件上。 ## ref > 被用来给元素或者子组件注册引用信息。引用信息将会被注册在父组件的\$refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就是指向组件实例： ``` hello 但是我们可以使用\$ref 在直接访问这个子组件。 - #### 适用环境： - 父组件调用子组件的方法，可以传递数据。 父组件： ``` 点击父组件 import ChildA from './components/child.vue' export default { components: { ChildA }, data() { return { msg: "我是父组件中的数据" } }, methods: { getMyEvent(){ this.$refs.child.emitEvent(this.msg); //调用子组件的方法，child是上边ref起的名字，emitEvent是子组件的方法。 } } } ``` 子组件： ``` 点击我 export default { methods: { emitEvent(msg){ console.log('接收的数据--------->'+msg)//接收的数据--------->我是父组件中的数据 } } } ``` - #### 交互过程 - 绑定「child-a」组件，定义为「child」 - 触发父组件的「getMyEvent」 - 调用子组件的方法，child 是上边 ref 起的名字，emitEvent 是子组件的方法。 - 子组件中「emitEvent」方法触发。 ## \$on(event,callback) - 参数： - {string | Array} event - {Funtion} callback - 用法： - 监听当前示例上的自定义事件。事件可以由 vm.\$emit 触发。回调函数会接收所传入事件触发函数的额外参数 - 适用环境： - 兄弟组件进行通信 ### 示例 - 首先创建一个 vue 的空白实例（兄弟间的桥梁） - 父组件 ``` import childa from './childa.vue'; import childb from './childb.vue'; export default { components:{ childa, childb }, data(){ return { msg:"" } }, methods:{ } } ``` - 子组件 A childa 发送方使用 ==\$emit== 自定义时间把数据带过去 ``` A组件->{{msg}} // 空的组件(兄弟的桥梁) import vmson from "../../../util/emptyVue" export default { data(){ return { msg:{ a:'111', b:'222' } } }, methods:{ send:function(){ vmson.$emit("aevent",this.msg) } } } ``` - 子组件 childb 而接收方通过 ==\$on==监听自定义时间的 callback 接收数据 ``` b组件,a传的的数据为->{{msg}} import vmson from "../../../util/emptyVue" export default { data(){ return { msg:"" } }, mounted(){ vmson.$on("aevent",(val)=>{ //监听事件aevent，回调函数要使用箭头函数; console.log(val);//打印结果：我是a组件的数据 this.msg = val; }) } } ``` #### 交互过程： - 定义一个父组件，作为 A/B 子组件的通信桥梁 - 在 A 组件来中设定一个自定义事件「aevent」 - 在 B 组件中，通过父组件「vmson」进行监听「aevent」事件的触发，进行回调 当然还有其他 API ![image](https://ws3.sinaimg.cn/large/006tNc79gy1g3j3ej34uaj30jm0jlaah.jpg)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-03-07-JavaScript的函数式编程(1)]]></title>
    <url>%2F2019%2F03%2F07%2F2019-03-07-JavaScript%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B(1)%2F</url>
    <content type="text"><![CDATA[--- title: '2019-03-07-JavaScript的函数式编程(1)' date: 2019-03-07 21:00:00 +0800 categories: 前端 tag: 笔记 --- ## 函数式编程 Funtional programming 函数式编程是一种编程范式，也就和如何写程序的方法论，属于结构化编程的一中，主要思想是把运算过程尽量写成一系列嵌套的函数调用 **学习函数式编程需要了解什么？** - 了解什么时候范畴论 - 数学模型和范畴之间的关系 - 范畴与函数式编程的关系 ## 什么是范畴论？ 函数式编程的起源，是一门叫范畴论（Caregory Theory）的数学分支 理解函数式编程的关键，就是理解范畴论。它是一门复杂的数学，认为世界上的所有的概念体系，都可以抽象成一个的‘范畴’ **范畴就是使用箭头连接的物体** 通俗的讲，就是彼此之间存在某种关系的概念、事务、对象等等，都构成范畴。 ![image](https://ws1.sinaimg.cn/large/006tKfTcgy1g0ujbfe6jej30hq0dbjrg.jpg) 箭头表示范畴成员之间的关系，正式名称叫做“态射”（morphism）。范畴论任务，同一个范畴的所有成员，就是不同状态的“形变”。通过“态射”就可以从一个成员形变成另一个成员。 ### 数学模型 既然“范畴“是满足某种形变关系的所有对象，就可以总结出来它的数学模型。 ``` 1.所有成员是一种集合 2.形变关系是函数 ``` 也就是说，范畴论是集合论更上层的抽象，简单的理解就是“集合+函数” 理论上通过函数，就可以从范畴的一个成员，算出其他所有成员 ### 范畴与容器 如果把“范畴”想象成一个容器，里面包含两样东西。 ``` 值（value） 值得变形关系，（函数） ``` 下面我们来定义一个简单的范畴 ``` class Category { // 实例化时，传过来的参数 constructor(a, b, c) { this.val = a + b + c; } addOn(x) { return x + 1; } } var a = new Category(12, 3, 4); console.log(a); // Category {val: 19} ``` 上面代码中，Category 是一个类，也是一个容器，里面包含了一个值(this.val)和一种变形关系(addOne)。该关系就是彼此之间都相差 1 的数字。 ### 范畴论和函数式编程的关系 > 范畴论使用函数，表达范畴之间的关系 伴随着范畴论的发展，就发展除了一整套函数的运算方法。方法起初只是适用于数学算法，后来有人将它在计算机上实现了，成为了今天的“函数式编程”。 **本质上，函数式编程只是范畴论的预算方法，跟数学逻辑、微积分、行列式都是一类东西，都是数学方法，只是正好用它来写程序。** ## 函数的合成与柯里化 函数式编程有 2 个最基本的运算 - 合成 - 柯里化 ### 合成 如果一个值要经过多个函数，才能变成另外一个值，就可以把所有的中间步骤合并成一个函数，叫做“函数的合成” ![image](https://ws1.sinaimg.cn/large/006tKfTcgy1g0ujbv9nszj309608swec.jpg) 上图中，X 和 Y 之间的变形关系是函数 f，Y 和 Z 的变形关系是 g，那么 X 和 Z 之间的关系，就是 g 和 f 的合成函数 g·f。 ``` const compose = function (f, g) { return function (x) { return f(g(y)); } } ``` ![image](https://ws4.sinaimg.cn/large/006tKfTcgy1g0ujc6qw2fj30m808pdfz.jpg) 函数的合成还必须要满足结合律 ``` compose(f,compse(g.h)); // 等同于 compose(compose(f,g),h); // 等同于 compose(f,g,h); ``` ### 柯里化 f(x)和 g(x)合成为 f(g(x)),有一个隐藏的前提，就是 f 和 g 都只能接受一个参数。如果接受多个参数，比如 f(x,y)和 g(a,b,c)，函数合成就很麻烦。 所以需要函数柯里化，把一个多参数的函数，转化为一个单参数的函数； ``` "use strict"; // 未柯里化 function add(x, y) { return alert(x + y); } // 柯里化后 function Xadd(x) { return function (y) { return alert(x + y); } } Xadd(2)(3);// 5 ``` 有了柯里化以后，我们就能做到，所以函数只能接受一个参数。 > 这里面包含了 ES6 的 class、constructor 等特性 ### JavaScript 的 class 在 ES5 的时候，我们编写 JavaScript 很多时候只能使用构造函数和原型链进行方法属性，实现 class 的功能 ``` // ES5环境 'use strict'; // Box是一个构造函数 function Box(val) { this.type = 'double'; this.color = val; } // 我们通过prototype的方式来添加一条属性 Box.prototype.hello = function () { console.log('hello,' + this.type + "," + this.color); } // 对于私有属性（static method）， 我们当然不能放在原型链上，我们直接放在构造函数上面。 Box.fn = function () { console.log('static'); } //通过new来创建 var circle = new Box('red'); circle.hello(); // hello,double,red ``` 但是在 ES6 的规范中，可以使用 class 语法，ES6 的 class 可以看做只是一个语法糖，它绝大部分都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更想面对对象编程的语法。 ``` // es6 class BoxES6 { constructor(val) { this.type = 'double'; this.color = val; } hello() { console.log('hello,' + this.type + ',' + this.color); } } //通过new来创建 var helloBlue = new BoxES6('blue'); helloBlue.hello(); // hello,double,blue ```]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-03-07-JavaScript的函数式编程(2)]]></title>
    <url>%2F2019%2F03%2F07%2F2019-03-11-JavaScript%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B(2)%2F</url>
    <content type="text"><![CDATA[--- title: '2019-03-07-JavaScript的函数式编程(2)' date: 2019-03-07 21:00:00 +0800 categories: 前端 tag: 笔记 --- > 本文中的知识点，我也不是很懂，比较难理解。 ## 涵子 ### 什么是涵子 涵子是函数式编程里面最重要的数据类型，也是最基本的运算单位和功能单位。 它是一种范畴（也是一种容器），包含了值和变形关系。比较特殊的是，它的变形关系可以依次作用于每一个值，**将当前容器变形为另一个容器**。 ![image](https://ws2.sinaimg.cn/large/006tKfTcgy1g0yw1xe4azj30of081q34.jpg) 上图中，左侧的圆圈就是一个汉字，表示人名的范畴。外部传入函数 f，会转成右边标示早餐的范畴。 ### 涵子的代码实现 任何具有 map 方法的素具结构，都可以当做涵子的实现。 ``` class Functor{ constructor(val){ this.val=val; } map(f){ return new Functor(f(this.val)); } } ``` 在上述代码中，FUnctor 是一个涵子，它的 map 方法接受函数 f 作为参数，最后返回一个新的涵子，里面包含的值是被 f 处理过的(f(this.val)); ``` (new Functor(2)).map(function (a) { // 由函数式表面，这是Funtor的return返回执行f(this.val) return a + 5; // 7 }); (new Functor("mynameisKisn")).map(function (a) { return a.toUpperCase(); //MYNAMEISKISN }); var res = (new Functor('bombs')).map(function (a) { return a.concat(' away'); }).map(function (a) { console.log(a); // bombs away return a.length; }); console.log(res); // Functor(10),this.val = 10; ``` 上面的栗子说明，函数式编程里面的运算，都是通过了涵子完成，即运算不直接针对值，而是针对这个值的容器-涵子，涵子本身具有对外接口（map 方法），各种函数就是运算符，通过接口接入容器， 引发容器值的变形。 > 其实后面还有一些别的涵子介绍，但是我就不对这个方面继续整理了，整体对能力、数据分析、逻辑要求都比较高，我比较菜就不深入学习，主要为了了解基础原理以及基础逻辑即可，后期等我学习完 VUE，我会继续深入学习。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-03-06-闭包(Closurce)]]></title>
    <url>%2F2019%2F03%2F06%2F2019-03-06-%E9%97%AD%E5%8C%85(Closurce)%2F</url>
    <content type="text"><![CDATA[--- title: '2019-03-06-闭包(Closurce)' date: 2019-03-06 21:00:00 +0800 categories: 前端 tag: 笔记 --- ## 什么是闭包？ 闭包就是能够读取其他函数内部变脸的函数。在 JavaScript 中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成「定义在一个函数内部的函数」。本质，闭包是将函数内部和函数外部连接起来的桥梁。 ### 变量的作用域 要了解闭包，首先必须了解 JavaScript 特殊的变量作用域。 - 全局变量 - 局部变量 ``` var a = 12345； // 全局变量 function f1(){ alert(a); } f1(); //12345 ``` 但是在函数外部自然不能读取函数内部的变量。 ``` function f1(){ var a = 12345; } alert(a); // error ``` > 在函数内部声明变量的时候，一定要使用 var，如果不使用，实际上你生命了一个全局变量 ``` function f1(){ a = 12345; } f1(); alert(n); // 12345 ``` ## 如何从外部读取局部变脸？ ### 在函数内部，在定义一个函数 ``` function f1(){ var n = 999; function f2(){ alert(n); // 999 } } ``` 在代码中，函数 f2 就被包含在函数 f1 内部，这是 f1 内部的所有全局变量，对 f2 都是可见的。但是反过来不行，f2 内部的局部变量，对 f1 是不可见的。只能子对象一级以及网上寻找所有父对象的变量。 ``` function f1(){ var n=999; function f2(){ alert(n); } return f2; } var res = f1(); res(); // 999 ``` 如上面的代码所示，f2 函数就是闭包。 ## 闭包的用途 闭包主要的在 - 可以读取函数内部的变量 - 让这些变脸的值始终保持在内存中 ``` function f1(){ var n = 999; nAdd = function(){ n += 1; } function f2(){ alert(n); } return f2; } var res = f1(); res(); // 999 nAdd(); res(); // 1000 ``` 在上述代码中，res 实际上就是闭包 f2 函数。他一共运行了 2 次，第一次的值是 999，第二次的值是 1000。这证明了，函数 f1 中的局部变量 n 一直保持在内存中，并没有在 f1 调用后被自动清除。 f1 是 f2 的富含，而 f2 被赋予了一个全局变脸，这导致 f2 永远存在内存中，而 f2 的存在依赖于 f1，因此 f1 也必须始终存在于内存中，不会在调用结束后，被垃圾回收机制回收。 **值得注意** ``` nAdd = function(){ n += 1; } ``` 首先，在 nAdd 前面没有加**var**,因此 nAdd 是一个全局变量，而不是局部棉量，其次 nAdd 的值是一个匿名函数，而这个匿名函数本身也是个闭包，所以 nAdd 相当于是一个 setter，可以在函数外部对内部的局部变量进行操作。 > 注意！ 「onAdd」这种函数写法，在严格模式（'use strict'）下是会报错的。 ## 使用闭包的注意点 - 由于闭包会使得函数的变量都被保存在内存中，内存消耗是很严重的，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中会导致内存泄漏。解决方法是，在退出函数前，将不使用的局部变量全部删除 - 闭包会在函数外部，改变父函数的内部变量的值。所以，如果你把父函数当做对象使用，把闭包当做他的公用方法，把内部变量当做他的私有属性，必须注意，不能随便改变父函数内部变量的值。 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 #### 好了写完了 --- 再说点？ > 今天整理完，感觉还有一些时间，分享下上周看的奥斯卡最佳影片「绿皮书」 特别喜欢这句对白 **「如果我不够黑人，也不够白人，又或不够男人，那请你告诉我，托尼，那我到底算是什么人！？」** 从学校踏入社会，也有快三年时间了，接触的人也越来越多。在我三观里，对于男女平权、种族仇恨等等，都比较模糊，我只是一直觉得人不可能存在在中立阶段，更多可能是偏左、右，不管从自然选择、和平演变，我觉得大多数人类更多站在自己的利益面发表自己的言论。 在我看来，这部电影给我最大的思考就就是 Don Shirley 在雨中对 Tony 的歇斯底里的怒吼，为什么人活着就要偏向人群所希望亦或一致认知的生活状态。乃至已经到了 Don 这种高度学历、地位、教育的人依旧困在自己的思想桎梏。 我经常告诉自己「可能你改不了世界的现状，也改不了身边的朋友、亲人的环境，至少在自己认知方面觉得可以坚持的事，认真坚持到底。」乃至可能也不够「黑」、不够「白」。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-03-05-JS的回收机制]]></title>
    <url>%2F2019%2F03%2F05%2F2019-03-05-JS%E7%9A%84%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[--- title: '2019-03-05-JS的回收机制' date: 2019-03-05 21:00:00 +0800 categories: 前端 tag: 笔记 --- ## 回收机制 > JS 为了防止内存泄露，会执行回收机制 ### 什么是内存泄漏？ 当已经不需要某块内存时，内存却还存在。 所以，回收机制就是阶段性的不定期去寻找不再使用的变量，并释放他们所指向的内存 比如如何处理哪些已经执行完毕的函数，如果么有外部应用，则会回收。 常用的两种垃圾回收规则： - 标记清除 - 引用计数 Javascript 引擎基础 GC 方案是（Simple GC）： **mark and sweep** —> 标记清楚 - 遍历所以可访问的对象 - 回收已不可访问的对象 比如： ``` 当变量进入环境时，例如，在函数中声明一个变量，就将它标记为「进入环境」 从逻辑上来讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用他它们。 而当变量离开环境的时候，则会标记「离开环境」 垃圾回收机在运行的时候会给存储在内存中的所有边浪都加上标记 然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记） 而在此之后再被加上标记的变量会将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了 最后垃圾回收期完成内存清除工作，销毁哪些带标记的值，并回收他们所占用的内存空间 ``` 简单的阐述： 跟踪记录每个值被引用的次数，当一个值被引用时，次数-1，减持时-1，下次垃圾回收器会收回次数为 0 的值的内存。 ### GC 的缺陷 出于安全考虑**GC 时，停止响应其他操作** 但是它操作时候在**100ms**甚至以上 对于一般应用还可以，但是对于 js 游戏，动画对连贯性要求比较高的应用，需要另外处理。 ### GC 的优化策略 #### 分带回收（Generation GC） 目的是通过区分「临时」与「持久」对象: - 多回收「临时对象」区（young generation） - 少回收「持久对象」区（tenured generation） - 减少每次需遍历的对象，从而减少每次 GC 的耗时。 ## 结语 「从输入 url 到页面渲染」文章已经整理（抄）完了，面对如此复杂的机制，很多地方依旧不理解，明天开始准备从基础慢慢开始学习。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-03-04-JS的执行阶段]]></title>
    <url>%2F2019%2F03%2F04%2F2019-03-04-JS%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[--- title: '2019-03-04-JS的执行阶段' date: 2019-03-04 21:00:00 +0800 categories: 前端 tag: 笔记 --- ## JS 的执行阶段 当解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含： - 执行上下文，执行堆栈概念（如全局上下文，当前活动上下文） - VO（变量对象）和 AO（活动对象） - 作用域脸 - this 机制 ### 执行上下文 - JS 有执行山下文 - 浏览器首次载入脚本，它将创建「全局执行上下文」，并亚压入执行栈栈顶（不可以被弹出） - 然后每进入其他作用域就创建对应的执行上下文并把它压入执行栈的顶部 - 一旦对应的上下文执行完毕，就会从栈顶端弹出，并将上下文控制权交给当前的栈 - 依次进行，直至回到全局执行上下文 如果程序执行完成，被弹出执行栈，然后有没有被应用（没有形成闭包），那么这个函数中用的内存就被垃圾处理自动回收。 ![image](https://ws1.sinaimg.cn/large/006tKfTcgy1g0qztu4q9vj30cv02fmx2.jpg) #### 每个执行上下文都有三个重要属性 - 变量对象（Variable object ， VO） - 作用域链（Scope chain） - this ![image](https://ws4.sinaimg.cn/large/006tKfTcgy1g0qzwz985ij309g06xq2x.jpg) #### VO 和 AO VO 是执行上下文的属性，但是只有全局上下文的变量对象允许通过 VO 的属性名称来间接访问（因为在全局上下文里，全局对象自身就是变量对象） AO（activation object），当函数被调用者激活，AO 就被创建了。 ``` 在函数上下文中：VO === AO 在全局上下文中：VO === this === global ``` 总体来说，VO 中会存放些变量信息（比如声明的变量，函数，arguments 参数等等） ### 作用域链 > 作为执行上下文的一个属性，原理和原型链很相似，作用很重要。 #### 流程简述 ``` 在函数上下文中，查找一个变量foo 如果函数的VO中找到了，就直接使用 否则去它的父级作用域中（__parent__）找 以此往上级找寻，直到全局上下文中没有找到报错。 ``` ![image](https://ws4.sinaimg.cn/large/006tKfTcgy1g0r08hdnhcj30650bu0sv.jpg) #### this 指针 **this 是执行上下文环境的一个属性，而不是某个变量对象的属性** 因此： - this 是没有一个类似搜寻变量的过程 - 当代码中使用了 this，这个 this 的值就直接从执行上下文中获取了，而不会从作用域链中搜寻 - this 的值在取决中进入上下文时的情况 举个例子 ``` var baz = 200; var bar = { baz: 100, foo: function() { consoloe.log(this.baz) } } var foo = bar.foo; // 进入环境： global foo(); // 200，但是严格环境下会报错，Cannot ready property 'baz' of undefined // 进入环境：global bar bar.foo(); // 100 ```]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-28-JS引擎解析过程-解释阶段]]></title>
    <url>%2F2019%2F02%2F28%2F2019-02-28-JS%E5%BC%95%E6%93%8E%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B-%E8%A7%A3%E9%87%8A%E9%98%B6%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[--- title: '2019-02-28-JS引擎解析过程-解释阶段' date: 2019-02-28 21:00:00 +0800 categories: 前端 tag: 笔记 --- ## JS 引擎解析过程 ### 什么是 JS 引擎？ > JavaScript 解析引擎是为「读懂」JavaScript 代码，并准确地给出代码运行结果的一段程序。 举个栗子： ``` var a = 1 + 1; ``` JavaScript 引擎所做的事情就是看懂（解析）这段代码，并将 a 的值变成 2 ### JS 的解释阶段 > JS 是解释型语言，所以它无需提前编译，而是由解释器实时运行的 引擎对 JS 的处理过程： ``` 1.读取代码，进行词法分析（Lexical analysis），然后讲代码分解成词元（token） 2.对词元进行语法分析（parsing），然后将代码整理成语法书（syntax tree） 3.使用翻译器（translator），将代码转为字节码（bytecode） 4.使用字节码解释器（bytecode interpreter），讲字节码转为机器码 ``` 最终计算机执行的就是机器码。 为了提高运行速度，浏览器一般采用即时翻译（JIT-JustIn Time compiler） 即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编码结果缓存（iniline cache） 这样会使整个程序的运行速度提升 而且对于不同的浏览器可能策略不同，有的浏览器为了省略了字节码的翻译过程，直接转为机器码（比如 chrome 的 v8） 总结：核心的 JIT 编译器可以将源码编译成机器码运行 ### JS 的预处理阶段 上述讲的解释器的整体过程，再讲一下在正式执行 JS 之前，还会有一个预处理阶段 - 变量提升 - 分号补全 - 处理变量冲突 - ··· #### 分号补全 这个比较简单 ``` console.log('a') console.log('b') ``` JS 预处理会在后面加上分号，因为 JS 解释器有一个「Semicolon Insertion」规则，他会按照一定规则，在适当的位置补充分号 规则（不全）: - 当有换行符的时候（包括含有换行符的多行注释），并且下一句 token 没有根前面的语法匹配时，自动添加分号。 - 当有}时候，如果缺少分号，会添加分号 - 程序源代码结束是，如果缺少分号，会补分号。 最终 ``` console.log('a'); console.log('b'); ``` 举一个反例 ``` function b() { return { a: 'a' }; } ``` 可能你想输入的结果是： ``` {a: 'a'} ``` 但是由于分号补全机制，最后会变成： ``` function b(){ return; { a:'a' } } ``` 运行以后就是 ``` undefined ``` 变量提升 > 在执行过程中，可能开头没有定义变量或者函数，但是往往并没有报错。 其中包括函数提升和变量提升 ``` a = 1; b(); function b(){ console.log('b'); } var a; b(); ``` 由于变量提升，最终结果,2 个 b()都会执行，a 会被赋值。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-27-CSS的可视化格式模型(2)]]></title>
    <url>%2F2019%2F02%2F27%2F2019-02-27-CSS%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B(2)%2F</url>
    <content type="text"><![CDATA[--- title: '2019-02-27-CSS的可视化格式模型(2)' date: 2019-02-27 21:00:00 +0800 categories: 前端 tag: 笔记 --- > 上一篇忘了说明什么是格式上下文（FC） ## FC > Formattinf Context,格式上下文。它定义了框内部的元素渲染规则，比较抽象。 FC 像是一个容器，里面内部包含元素。容器可以隔开里面的额元素和外面的元素，保护内部元素被外部元素影响。 > 注意，并不是说所有的框都产生 FC，而是符合特定条件才会产生，只有产生了对于的 FC 后才会应用对应渲染规则 ## IFC（inline Formatting Context） > 行内框产生的格式上下文 ### IFC 规则 ``` 在行内格式化上下文中框一个接一个水平排列，七点是包含块的顶部。 水平方向上的margin，border和padding在框之间得以保留 框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐 浮动元素可能会处于包含块的边缘和行款边缘之间 尽管在相同的行内格式胡上下问中的行框通常拥有相同的宽度，他们可能会因为浮动元素缩短了可用宽度，而在宽度上发生变化 同一行内格式化上下文中的行框通常高度不一样（如，一行包含了一个高的图形，而其他行只包含了文本） 当一行中行内宽度和总和小鱼包含他们的行框的宽，他们在水平方向上对齐，取决于「text-align」的属性 空的行内框应该被忽略 及不包含,保留空白符，margrin/padding/border非0的行内元素，以及其他常规流中的内容（比如，图片，inline-blcoks和inline-tables）并且不是以换行结束的行框， 必须被当做零高度行框对待 ``` ### 行匡 包含那些框的长方形区域，会形成一行，叫行框 行框的宽度由它的包含块和其中的浮动元素决定，高度的确定由行高度计算规则决定 ### 行框的规则 ``` 如果几个行内框在水平方向无法放入一个行框内，它们可以分配在两个或者多个行框垂直堆叠的行框内 行框在堆叠时没有垂直方向上的分割且永不重叠 行框的高度总是足够容纳所包含的所有框，不过他可能高于它包含的最高的框 行框的左边接触到其包含快的左边，后边接触到其包含块的右边 ``` ### 总结 - 行内元素总会应用 IFC 渲染规则 - 行内元素会应用 IFC 规则渲染，例如「text-align」可以用来居中 - 块框内部，对语文本这类的匿名元素，会产生匿名行框包围，而行框内部就应用 IFC 渲染规则 - 行内框内部，对于那些行内元素，应该应用 IFC 渲染规则 - 另外， 「inline-block」，挥着元素外层生成 IFC（所以这个元素是可以通过「text-align」来水平居中的），当然它内部则是按照 BFC 规则渲染 #### 相比较 BFC 规则，IFC 可能更加抽奖（因为没有那么清晰的规则和触发条件） #### 但是总体来说，它就是行内元素自身如何显示以及在框内如何摆放的渲染规则。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-26-CSS的可视化格式模型]]></title>
    <url>%2F2019%2F02%2F26%2F2019-02-26-CSS%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[--- title: '2019-02-26-CSS的可视化格式模型' date: 2019-02-26 21:00:00 +0800 categories: 前端 tag: 笔记 --- ## CSS 的可视化格式模型 ### 简介 - CSS 中规定每个元素都有自己的盒子模型 - 可视化格式模型则是把这些盒子按照规则摆放到页面上布局 - 盒子模型规定了怎么在页面上布局盒子和盒子之间的相互作用 CSS 的可视化格式模型规定了浏览器在页面中如何处理文档树 其中包括了 ``` 包含块（Containing Block) 控制框（Controlling Box） BFC（Block Formatting Context） IF（Inline Formatting Context） 定位体系 浮动 ``` CSS 包含了三种定位机制：**普通**，**浮动**，**决定定位** ### 包含快（Containing Block） > 一个元素的 box 的定位尺寸，会与某个矩形框有关，这个框就称之为包含块。元素会为他的子孙元素创建包含块，但是并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系 通俗的讲，就是定位参考框或者定位左边参考系 比如： - 根元素是最顶端的元素，它没有父节点，它的包含块就是初始包含块 - static 和 relative 的包含块是由它最近的块级、单元格或者行内块祖先元素的内容框（content）创建的。 - fixed 的包含块是当前的可是窗口 - absolute 的包含块由他最近的 position 属性为**abosolute**，**relative**，**fixed**的祖先元素创建 - 如果其祖先元素是行内元素，则包含块取决于其祖先元素的 direction 特性 - 如果祖先元素不是行内元素，那么包含块的区域应该为祖先元素的内边距边界 > direction: 设置文本方向 ``` div{ direction: rtl; rtl //文本方向从右到左。 ltl //默认。文本方向从左到右。 inherit //规定应该从父元素继承 direction 属性的值。 } ``` ### 控制框（Controlling Box） > 块级元素和块框以及行内元素和行框的相关概念 **块框** - 块级元素会生成一个块框（Block Box），块框会占据一整行，用来包含子 box 和生成的内容 - 块框同时也是一个块包含框（Containing Box），里面要么只包含块框，要么只能包含行内块（不能混淆），如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围 #### 匿名块框 ``` Some text More text ``` div 生成一个块框，包含了另外一个块框 p 以及文本内容「Sometext」，此时「Some text」文本会被强制加上一个匿名的块框里面，被 div 生成的块框包含 如果一个块框在其中包含了另外一个块框，那么我们强迫它只能包含块框，因此其他文本内容生产出来的都是匿名块框 #### 行内框 - 一个行内元素生成一个行内框 - 行内元素能排在一行，允许左右有其他元素 关于匿名行内框的生成： ``` Some emphasized text ``` p 元素生成一个块框，其中有几个行内框（如 EM），以及文本「Some」「text」，此时会专门为这些文本生成匿名行内狂 #### display 属性影响 display 的几个属性也可以影响不同框的生成： - block：元素生成一个块框 - inline：元素生成一个或多个行内框 - inline-block：元素生成一个行内块级框，行内块级的内部会被当做块级来格式化，因此元素本身会被当做行内框来格式化 - none：不生成框，不在格式化结构中 > visibility:hidden 产生一个不可见的框 #### 总结 1.如果一个框内有一个块级元素，那么这个框里的内容都会被当做块框来进行格式化，因为只要出现块级元素，就会将里面的内容分块几块，每一块独占一行（出现行内，则用匿名块框包含） 2.如果一个框内，没有任何块级元素，那么这个框里的内容会被当做行内框来格式化，因为里面的内容按照顺序成行的排列 ### BFC（Block Formatting Context） > 块级格式化上下文，浮动元素和绝对定位元素，非块级盒子的块级，以及 overflow 不为「visiable」的块级盒子，都会为他们的内容创建新的 BFC 在块级格式化上下文中，每个元素左边与包含块的左边相接触（对于从右到左的格式化，右外边接触右边），即使寸浮动也是如此（所以浮动元素正常会直接贴近它的包含块的左边，与普通元素重合） > 除非这个元素也创建一个新的 BFC #### 特点： 1.内部 box 在垂直防线，一个接一个的放置 2.box 的垂直方向由 margin 决定，属于同一个 BFC 的两个 box 间的 margin 会重叠（这个比较重要） 3.BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响外卖的元素。 4.计算 BFC 的高度时候，浮动元素也会计算（不会浮动坍塌） #### 如何触发 BFC？ 1.根元素 2.float 不为 none 3.position 为 absolute 或者 fixed 4.dispaly 为 inline-block、flex、inline-flex、table、tablec-cell、table-caption 5.overflow 不为 visible > ps:「display:table」，它本身不产生 BFC，但是它会产生匿名框（包含 display:table-cell 的框），而这个匿名框产生 BFC]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-21-解析页面流程（3）HTML初始化遇到外链的处理]]></title>
    <url>%2F2019%2F02%2F21%2F2019-02-21-%E8%A7%A3%E6%9E%90%E9%A1%B5%E9%9D%A2%E6%B5%81%E7%A8%8B%EF%BC%883%EF%BC%89HTML%E5%88%9D%E5%A7%8B%E5%8C%96%E9%81%87%E5%88%B0%E5%A4%96%E9%93%BE%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[--- title: '2019-02-21-解析页面流程（3）HTML初始化遇到外链的处理' date: 2019-02-21 21:00:00 +0800 categories: 前端 tag: 笔记 --- ## Chrome 中的调试 Chrome 的开发者工具中，Perfromance 中可以看到详细的渲染工程 ![image](https://ws3.sinaimg.cn/large/006tKfTcgy1g0ebgvx4h6j30p00c0ab4.jpg) ## 资源外链的下载 > 在解析 html 时，会遇到一些资源链接，此时需要进行单独处理 一般情况，静态资源分为几个大类（未全列举）： - CSS 样式资源 - JS 脚本资源 - img 图片资源 #### 遇到外链时的处理 当遇到上述外链的时候，会独立开启一个下载线程去下载资源（HTTP1.1） #### 遇到 CSS 样式资源 CSS 资源的处理有几个特点 - CSS 下载时异步，不会阻塞浏览器构建 DOM 树 - 但是会阻塞渲染，也就是在构建 render 时候，会等到 css 下载解析完毕才会进行。（这与浏览器优化有关，防止 css 规则不断改变，避免了重复的构建） - 「media query」声明的 CSS 是不会阻塞渲染的 ### 遇到 JS 脚本资源 JS 脚本资源的处理有几个特点： - 阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会解析 HTML - 浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其他资源（当然也有并发上限），但是虽然脚本可以并行下载，但是解析过程仍然是阻塞的，也即是说必须这个脚本和执行完成后才能继续解析，并行下载只是一个优化操作 - defer 与 async，普通德积小本是会阻塞浏览器解析的，但是可以加上 defer 或者 async 属性，这样脚本就会变成异步了，可以等待解析结束后执行脚本。 > 值得注意的是，defer 是延迟执行，async 是异步执行 简单的来说： - 「async」是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在 onload 钱，但是不确定在「DOMContentLoaded」事件的前或者后 - 「defer」是延迟执行，在浏览器看起来的效果像是将脚本放在 body 后面一样。 #### DOMContentLoaded 事件和 onload 事件的区别 ``` DOMContentLoaded: 当初始的HTML文档被完全加载和解析后，被触发，无需等待样式表、图像和子框架的加载完成。 onload:仅用于检测一个完全加载的页面（图像、CSS资源等） ``` #### 遇到 img 图片类资源 遇到图片资源时候，直接是异步下载，不会阻塞解析，下载完成后直接使用图片替换原有 SRC > html 基本整理好了，明天和同事有个聚会，就暂时偷个懒，下周开始整理 CSS]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-20 解析页面流程（2）生成CSS规则和构建渲染]]></title>
    <url>%2F2019%2F02%2F20%2F2019-02-20-%E8%A7%A3%E6%9E%90%E9%A1%B5%E9%9D%A2%E6%B5%81%E7%A8%8B%EF%BC%882%EF%BC%89%E7%94%9F%E6%88%90CSS%E8%A7%84%E5%88%99%E5%92%8C%E6%9E%84%E5%BB%BA%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[--- title: '2019-02-20 解析页面流程（2）生成CSS规则和构建渲染' date: 2019-02-20 21:00:00 +0800 categories: 前端 tag: 笔记 --- ## 生成 CSS 规则 同理，CSS 规则树的生成也是类似 ``` Bytes -> character -> tokens -> nodes -> CSSOM ``` ``` 1.Conversion：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符 2.Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都他有自己独特的含义以及规则及 3.Lexing词法分析：分词的结果是得到了堆的token，此时把他们的转换为对象，这些对象分别定义了他们的属性和规则 4.DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构。 ``` ### 举个例子 #### CSS 代码 ``` body { font-size: 16px } p { font-weight: bold } span { color: red } p span { display: none } img { float: right } ``` #### DOM 树： ![image](https://ws4.sinaimg.cn/large/006tKfTcgy1g0csljk8rsj30g608bq38.jpg) ## 构建渲染书 > 现在「CSS 树」和「DOM 树」都已经完成，浏览器现在要开始构建渲染树了。 > 一般情况，「渲染树」和「DOM 树」相对应的， 但是也不定，因为有些不可见的（display:none;）等等不可见的标签会影响「渲染树」 > ![image](https://ws4.sinaimg.cn/large/006tKfTcgy1g0cspjnnvqj30p00bo0ti.jpg) ### 渲染 > 有了渲染书（render），开始渲染： ![image](https://ws3.sinaimg.cn/large/006tKfTcgy1g0csqsdknsj30m8064q3c.jpg) 分为四个步骤: ``` 1.计算CSS样式 2.构建渲染书 3.布局，主要定位坐标的和大小，是否换行，各种position overflow z-index 属性 4.绘制，将图像绘制出来 ``` 然后，图中的线与箭头表示通过 JS 动态修改了 DOM 或者 CSS，会导致页面「重新布局（Layout）」、「渲染（Repaint）」 ### 什么是回流? > Layout,也叫 Reflow。html 的内容。结构、位置或尺寸发送了变化，需要重新计划样式和渲染树 ### 什么是重绘？ > Repaint。元素发生的改变只是影响了元素本身的一些外观之类的（背景，边框颜色等），此时只需要应用新样式绘制这个元素就可以了 回流的成本开销>重绘的成本开销，而且一个节点的回流往往导致子节点以及同级节点的回流。 ### 什么会引起回流？ ``` 1.页面渲染初始化 2.DOM结构改变，比如删除了某个节点 3.render树变化，比如减少了padding 4.窗口resize 5.获取某些属性 6.改变字体大小 ``` 很多浏览器会对回流做优化，会等到数量足够是做一次批处理回流， 但是处理 render 树的直接变化，当获取一些属性的时候，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括： ``` 1.offset（Top/Left/Width/Height） 2.scroll（Top/Left/Width/Height） 3.cilent（Top/Left/Width/Height） 4.width,height 5.调用了getComputedStyle()/IE的currentStyle ``` #### 回流优化方案 - 减少逐项更改样式，最好一次性更改 style，或者将样式定义为 Class 并一次性更新 - 避免循环操作 dom，创建一个 documentFragment 或者 div，在它上面应用所以 DOM 操作，最后把它添加到 window.document 上 - 避免多次读取 offest 等属性。无法避免则将他们缓存为变量。 - 将复杂的元素绝对定位或者固定定位，使得他们脱离文档流，否则回流代价会很高 举个栗子： ``` var s = document.body.style; s.padding = "2px"; // 回流+重绘 s.border = "1px solid red"; // 再一次 回流+重绘 s.color = "blue"; // 再一次重绘 s.backgroundColor = "#ccc"; // 再一次 重绘 s.fontSize = "14px"; // 再一次 回流+重绘 // 添加node，再一次 回流+重绘 document.body.appendChild(document.createTextNode('abc!')); ``` ### 简单层与复杂层 上述中的渲染中止步于绘制，但实际上绘制这一步，需要从简单层和复杂层来讲。 - 可以默认只有一个复合图层，所有的 DOM 节点都在这个图层上面， - 如果开启了硬件加速功能，可以将某个节点转为复合图层 - 复合涂层之间的绘制互不干扰，由 GPU 控制 - 而简单图层中，就算是 absolute 等布局，变化的时候不影响整体的回流，但是由于在同一个图层中，仍然是会影响绘制的，因此做动画的时候性能仍然很低，而复合图层是独立的，所以一般动画推荐使用硬件加速。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-19 解析页面流程(1) 解析HTML，构建DOM树]]></title>
    <url>%2F2019%2F02%2F19%2F2019-02-19-%E8%A7%A3%E6%9E%90%E9%A1%B5%E9%9D%A2%E6%B5%81%E7%A8%8B%EF%BC%881%EF%BC%89%20%E8%A7%A3%E6%9E%90HTML%EF%BC%8C%E6%9E%84%E5%BB%BADOM%E6%A0%91%2F</url>
    <content type="text"><![CDATA[--- title: '2019-02-19 解析页面流程(1) 解析HTML，构建DOM树' date: 2019-02-19 21:00:00 +0800 categories: 前端 tag: 笔记 --- > http 请求完成，浏览器获取到了 html，开始解析并且渲染 HTML ### 总体流程 浏览器内核拿到内容后，渲染步骤： ``` 1.解析HTML，构建DOM树 2.解析CSS，生成CSS规则树 3.合并DOM树和CSS规则，生成render树 4.布局render树（Layout/reflow），负责各元素尺寸、位置的计算 5.绘制render数据（paint），绘制页面像素信息 6.浏览器会将各层的信息发送给GPU,GPU会将各层合成（composite），显示在屏幕上 ``` ![image](https://ws1.sinaimg.cn/large/006tKfTcgy1g0c03h0oqqj30p009sq33.jpg) ### 解析 HTML，构建 DOM 树 > 这是渲染流程第一步，浏览器将解析 HTML，构建成 DOM 树， ``` 流程：Bytes -> characters -> tokens -> node -> DOM ``` ``` Critical Path Hello web performance students! ``` #### 浏览器处理流程大概是这个样子 ``` 1.Conversion转换 -> 数据字节流（HTML内容Btyes）基于他的编码生成单个字符 2.Tokenizing分词 -> 由数据字节按浏览器HTML规范标准版生成标签、内容（标记TOKEN），每个TOKEN有他自己的定义和规则集 3.Lexing词法分析 -> 由白标签、内容成Token，此时把它们转换为对象，这些对象分别定义了他们的属性和4规则（header/p/span） 4.DOM构建-> 开始构建由不同的html标签的关系来渲染父->子结构的树状结构。 ``` #### 浏览器处理示意图： ![iamge](https://ws4.sinaimg.cn/large/006tKfTcgy1g0c06x3e19j30p00du3zh.jpg) #### 形成 DOM 树： ![image](https://ws3.sinaimg.cn/large/006tKfTcgy1g0c083cudtj30ih07wq36.jpg) ### 结语 > 今天的内容比较少，一是最近工作挺多的，二是今天家里换了 200M 的网（免费的~~~~~~~ 开心~~~~~），突然发现原先的路由器「小米路由器 3」和「小米电力猫」、交换机均不支持 200M 的速率，LAN 和 WAN 端口支持 100M，so 要花点时间挑选一个性价比高的路由器的电力猫。 ![image](https://ws2.sinaimg.cn/large/006tKfTcgy1g0c0foevnhj30hs0gyq3u.jpg)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-18-http2.0、https（2）]]></title>
    <url>%2F2019%2F02%2F18%2F2019-02-18-http2.0%E3%80%81https%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[--- title: '2019-02-18-http2.0、https（2）' date: 2019-02-18 21:00:00 +0800 categories: 前端 tag: 笔记 --- ## 头部的区别 > 从 http1.0 到 http1.1，改进了很多头部 - http1.0 的缓存控制： - Pragma：严格来说，它不属于专门的缓存控制头，但是它设置了「no-cache」可以让本地强缓存失效（相当于一个配置项） - Expires：服务器配置，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires 一般对应服务器端时间，如 Expires：Fri，30 Oct 2001 12:22:12 - If-Modifien-Since/Last-Modifed:这个、两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是「If-Modified-Since」，而服务端的是「Last-Modified」，他的作用是，在发起请求时，如果「If-Modified-Since」和「Last-Modified」匹配， 那么代表服务器资源并未改变，因此服务器不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。「Last-Modified」-> 文件最后修改的时间，只能精确到 1s - http1.1 的缓存控制： - Cache-Control：缓存控制头部，有 no-cache、max-age 等多种取值。 - Max-Age： 服务器配置的，用来控制强缓存，在规定的时间之内，浏览器无需发送请求，直接使用本地缓存，注意「Max-Age」是「Cache-Control」的值，不是独立的头部，例如「Cache-Control:max-age=3600」,而且它的值是绝对时间，由服务器计算 - If-None-Match/E-tag:这两个是成对出现的，属于协商缓存的内容，其实浏览器头部的是「If-None-Match」，而服务端的是「E-tag」，同样，发出请求后， 如果「If-None-Match」和「E-tag」匹配，则代表内容未变，通知浏览器使用本地缓存，和「Last-Modified」不同，「E-tag」更精确，它是类似于指纹一样的东西，基于「FileEtag INode Mtime Size」生成的，也是只要文件变，指纹就会变，而且没有任何精度限制 ### Max-Age 与 Expires 的区别 「Expires」使用的是服务器端的本地时间，但是有时客户端时间好服务器端时间不同步，导致了浏览器本地的缓存失效或者过期 所以不推荐 Expires，而且 Max-Age 使用的是客户端本地时间计算，所以不会有这个问题，所以推荐使用 Max-Age #### PS：同时启动了 Cache-Control 与 Expires，Cache-Contrl 优先级更高。 ### E-tag 和 Last-Modified 的区别 - Last-Modified: - 表明服务器端的文件时最后何时改变的 - 缺点：只能精确到 1s - 服务端的文件会周期性改变，导致缓存失效 - E-tag： - 是一种种指纹机制，可以代表文件的相关唯一性 - 只有文件改变，缓存才会变 - 没有精确时间的限定 ### 图解 ![image](https://ws1.sinaimg.cn/large/006tKfTcgy1g0atbc7vpfj30m80djq34.jpg) ### 结语 > 第一步，HTTP 请求终于讲完了，其实我之前对整个请求体系基本不知道多少。明天开始我会开始整理（抄）解析页面流程，敬请期待！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-17-http2.0、https（1）]]></title>
    <url>%2F2019%2F02%2F17%2F2019-02-17-http2.0%E3%80%81https%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[--- title: '2019-02-17-http2.0、https（1）' date: 2019-02-17 21:00:00 +0800 categories: 前端 tag: 笔记 --- ## http2.0 > HTTP/2，即超文本传输协议 2.0，是下一代 HTTP 协议。是互联网工程任务组的 httpbis 小组开发进行。在开放互联网上 HTTP 2.0 将只用于 https:\/\/网址，而 http:\/\/ 网址将继续使用 HTTP/1，目的是在开放互联网上增加使用加密技术，以提供强有力的保护去遏制主动攻击。DANE RFC6698 允许域名管理员不通过第三方 CA 自行发行证书 就是 http 的下一代规范 ### http2.0 和 http1.1 的不同之处 - http1.1 中，每次请求资源都需要开启一个 tcp/ip 请求，因为 tcp/ip 有并发数炼制，所以当资源一多，就会影响页面加载速度。 - http2.0，一个 tcp/ip 请求可请求多个资源，提高效率 - http2.0 采用二进制而非文本格式，将所有的信息分割为更小的消息和帧，提高请求速度，降低延迟。 - http2.0 使用报头压缩 - http2.0 可以让服务端对客户端的一个请求，响应多次，主动推送到客户端缓存中 - 请求优先级，当所有资源都并发请求的时候，可以对特定的资源进行优先传输。 ## https > HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的 HTTP 通道。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 如果需要将网站升级为 https，需要后端去申请证书（SSL）等，同时 http 请求的时候所传输的信息更大，建议 htpp2.0+https。 ### SSL > Secure Sockets Layer，安全套接层，一种安全协议，为 TCP/IP 于各种应用层协议之间，为数据通讯提供安全支持。 ### TLS > Transport Layer Security，及其前身安全套接层（Secure Sockets Layer，缩写作 SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。该协议由两层组成：TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshak） ### SSL/TLS 的 握手流程： ``` 1.浏览器请求建立SSL连接，并向服务端发送一个随机数-Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。 2.服务端从中选出一组加密算法与HAash算法，回复一个随机数-Server random，并将自己的身份信息以证书的形式发回给客户端（证书中包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息） 3.浏览器收到服务器端的证书后 1）验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁，否则会有提示 2）用户接收证书后（不管信不信任），浏览器会生成一个新的随机数-Premaster Secret，然后证书中的公钥以及制定的加密方法加密「Premaster secret」，发送给服务器端 3）利用Client random、Server random以及Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-「seesion key」。 4）使用约定好的Hash算法计算握手消息，并使用生成的「session key」对消息进行加密，最后将之前生成的所有信息发送给服务端。 4.服务端收到浏览器的回复 1）利用已知的加解密方式与自己的私钥进行解密，获取「Premaster secret」 2）和浏览器相同规则生成「seesion key」 3）使用「session key」解密浏览器发送的握手消息，并验证Hash是否和浏览器发送的一致 4）使用「seesion key」加密一段握手消息，发送给浏览器 5.浏览器解密并计算握手消息的Hash，如果与服务器端发来的Hash一样，此时握手流程结束。 ``` ### SLL/TLS 握手规则示意图 > 写了五六遍，勉强能写出像样的示意图，请见谅 ![iamges](https://ws1.sinaimg.cn/large/006tKfTcgy1g09pvdj80sj30u0140jv8.jpg) ### http 的缓存 > 前后端的 http 交互中，使用缓存能很大程度上的提升效率，而且对有性能有要求的前端项目都是必用缓存的 #### 强缓存与弱缓存 缓存可以分为两种类型： - 强缓存（200 from cache） - 协商缓存 （304） 区别： - 强缓存时，浏览器如果判断本地缓存未过期就会直接使用，无需发起 http 请求 - 协商缓存时，浏览器会向服务端发起 http 请求，然后服务端告诉浏览器「文件为改变」，让浏览器使用本地缓存 对于协商缓存，使用 ctrl + F5 强制刷新可以是协商缓存失效 但是对于强缓存，在未过期是，必须更新资源路径才能发起新的请求 ### 缓存头部 #### 如何区分强缓存和协商缓存 常用强缓存： - Cache-Control/Max-age (http1.1) - Pragma/Expires (http1.0) 常用协商缓存: - If-None-Match/E-tag (http1.1) - If-Modified-Since/last-Modified (http1.0) 使用「meta」标签可以控制缓存方案-Pragma ``` ``` > Pragma 方案，支持情况不佳，缓存代理服务器不支持]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie和gizp压缩、长连接与短连接]]></title>
    <url>%2F2019%2F02%2F16%2F2019-02-16-cookie%E5%92%8Cgzip%E3%80%81%E9%95%BF%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[--- title: 'Cookie和gizp压缩、长连接与短连接' date: 2019-02-16 21:00:00 +0800 categories: 前端 tag: 笔记 --- > 今天有些忙，晚上二刷完「流浪地球」才回家，继续整理下昨天接下来的「Cookie」 ## Cookie ### 什么是 Cookie？ > Cookie, 网站为了辨别用户身份、进行 session 跟踪而存储在用户本地终端的数据（加密），规范为 RFC6265 通俗的来说，就是「浏览器缓存」，在网站上来用帮助客户端和服务器校验身份，或者交换数据（通信），结合服务器的 seesion 使用。 举个栗子： ``` 在login页面进行登录的时候，用户点击「登录」 此时，服务端会生成一个seesion，seesion中有对于用户的信息（账号、密码等） 然后会生成一个sessionid（相当于是服务端的这个seesion对应的key） 然后服务器端在登录页面中写入cookie，值就是jessionid=xxx 最后浏览器中本地就有这个cookie，以后再访问同域名下的页面的时候，自动就带上这个sessionid了，就不需要自动登录了。 ``` ![image](https://ws1.sinaimg.cn/large/006tKfTcgy1g08oox73ggj30nq0mewht.jpg) 一般来说 cookie 是不允许存放敏感信息的（禁止明文存储账号、密码） 因为在同域名的资源氢气下，浏览器会默认带上本地的 cookie，所以在某些不想带 cookie 信息的情况下，还需要另外处理 ``` 客户端在域名A下有cookie 但是A下有一个页面，页面中有很多依赖的静态资源（资源都在域名A服务器下面） 此时就在请求这些静态页面的时候，浏览器就会默认带上cookie 这样就会降低访问速度，浪费效能 ``` 比较稳当的解决办法，就是「多域名拆分」。具体作坊就是 - 讲静态资源，分别放在不同的域名下（带 cookie 的：www.a.com,不需要带 cookie：wwww.c.com） - 而 a.com 在加载页面的时候，加载静态页面就不会带 cookie #### 多域名拆分 在移动端，如果请求的域名过多，会降低请求速度，因为域名解析流程也是需要时间 此时，就需要再加一份优化方案「dns-prefetch」，让浏览器在空闲时提前解析 dns 域名。 ### cookie 的交互 ![image](https://ws3.sinaimg.cn/large/006tKfTcgy1g08p2fv8khj30pg0grwf7.jpg) ## gzip 压缩 > http 协议上的 gzip 编码是中用来改进 WEB 应用程序性能的技术。可以让用户更快的速度请求。 gzip 是一中压缩格式，需要浏览器支持才有效，压缩效率比较优秀 gzip 一般在「apache」、「tomcat」等 web 服务器开启 ## 长连接与短连接 ### tcp/ip 中的定义 - 长连接：一个 tcp/ip 连接上可以连续发送多个数据包，在 tcp 保持连接期间，如果没有数据包发送，需要双方发检验测试包以维持连接，一般需要自己做在线维持。 - 短连接：通信双方有数据交互时，就建立一个 tcp 连接，数据交互完成，销毁。 ### http 的定义： - http1.0 中，默认使用的是短连接，浏览器每进行一次 http 操作，就会建立一次连接，交互结束销毁连接。 - http1.1 中，默认使用长连接，使用长连接会有「Connection:keep-alive」，在长连接情况下，当一个页面打开完成后，客户端和服务端之前用于传输 http 的 tcvp 就不会关闭，如果客户端再次访问这个服务器页面，则会继续使用这条建立过的连接 > PS：keep-alive 不会永远保持，也有时间，一般配置在服务器中，另外长连接也需要客户端和服务器都支持该配置才有效。 ### 结语 本来还想整理（抄）一下 http2.0 和 https 的定义和区别，但是时间不早了，该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 该睡了。 ### 诶...你怎么还不睡..? 那么我来写（copy）个彩蛋吧？ > 事情是这样的，我 banner 上写的是一句日文「今でもあなたはわたしの光」，来自米津玄師的「Lemon」。然后我哥提醒我「わたし」一般是女的才用，毕竟我哥日文水平还是可以不错的，于是我和我哥就去查了下资料。 ![](https://ws3.sinaimg.cn/large/006tKfTcgy1g08pipshysj30i613egnd.jpg) 以下是来 wiki 的解释 ![image](https://ws4.sinaimg.cn/large/006tKfTcgy1g08pvo9n9pj31e70u0wo1.jpg) - 私（わたし／watashi） 日本人用得最多的一人称。「わたくし」的谦逊说法。男女老少都用，礼貌用语。特别公开场合男的用这个就很礼貌，用「わたくし」就更礼貌了。女性更比男性常用。 - 私（わたくし／watakushi） 「私」的自谦、郑重语，对年龄比自己大，地位比自己高的时候使用。公开郑重场合用这个最礼貌。特别是皇族公开演说必须用这个，因为皇族在面向国民的时候需要用自谦的语气说话。 - 自分（じぶん／zibun） 体育协会那些男生多用。相扑力士和棒球选手常用。刑事日剧『西部警察』里面渡哲也演的主人公大門圭介使用这个很有名で、一时期成为了流行語。 在文章里面也常用语一人称，这种时候女的也有用的。但是在正式的文书和商务文书禁用。 - 僕（ぼく／boku） 男性在私下场合对同辈或长辈常用，在较正式的场合也有用的，给人亲近、随和的感觉是一种自谦语。就像字面上说的“请把我作为仆人召唤”的感觉，这种时候女性可以用「妾（ショウ）」。 - 俺（おれ／ore） 一般只能男的私下场合用，只能对同辈或者晚辈使用。因为是俗语，所以公开场合不用。用在路飞身上再好不过。 > 还有好多语法，我就不一一 google translate 了...附上链接:https://ja.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AE%E4%B8%80%E4%BA%BA%E7%A7%B0%E4%BB%A3%E5%90%8D%E8%A9%9E#%E7%A7%81%EF%BC%88%E3%82%8F%E3%81%9F%E3%81%97%EF%BC%89 （查看请示用「科学上网」） #### 现在发现有很多东西需要学习，不单单为了我个人的薪资或者理想，可能更多的是想更加了解一点世界。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器如何发起一个完整的HTTP请求(2)]]></title>
    <url>%2F2019%2F02%2F15%2F2019-02-15-http(2)%2F</url>
    <content type="text"><![CDATA[--- title: '浏览器如何发起一个完整的HTTP请求(2)' date: 2019-02-15 21:00:00 +0800 categories: 前端 tag: 笔记 --- > 昨天看到请求头部分，整理一些通用请求头，下面整理下常用的响应/请求头 ## 常用的请求头部 ![image](https://ws3.sinaimg.cn/large/006tKfTcgy1g07d0evn94j30h807u3yq.jpg) ``` Accept：接受类型，标示浏览器支持的MIME类型（对标服务器返回的Centent-Type） Accept-Encoding： 浏览器支持的压缩类型，比如gzip等，超过类型不能接受 Content-Type：客户端发送出去实体内容的类型 Cache-Control：指定请求和响应遵循的缓存机制，如no-cache、no-store If-Modified-Since：对应服务器的Last-Modified,用来匹配看文件是否变动，精确到1s Expires：缓存控制，在这个时间内不会请求，直接使用缓存（http1.0，而且是服务器端时间） Max-age： 代表资源在本地缓存多少秒，有效时间不会请求，而是使用缓存（http1.1） If-None-Match：对于服务端的ETag，用于匹配文件内容是否改变（非常精确）（http1.1） Cookie：有cookie并且同域访问时会自动带上（www.baidu.com/a.baidu.com非同域名！） Host：请求的服务器URL Origin：最初请求是从哪里发起的（精确到端口），Origin比Referer更遵循隐私 Referer：该页面的来源URL（适用于所有类型的请求，会精确到详细页面，csrf通常会拦截该字段） User-Agent：用户客户端的一些必要信息 ``` **备注** > no-cache:可以在本地缓存，可以代理服务器缓存，但是和这个缓存需要服务器验证以后才可以使用 > no-store:禁用缓存，本地和代理服务器均不准使用,必须从服务器获取 ### Accept 和 Content-Type 的区别 ``` Accpet属于请求头，Content-Type属于实体头 Accpet：告诉服务端，客户端接收什么类型的信息 Content-Type：发送端（客户端|服务器端）发送的实体数据的数据类型 ``` ## 常用的响应头 ![image](https://ws4.sinaimg.cn/large/006tKfTcgy1g07d2tzlz5j30gq08zglu.jpg) ``` Access-Control-Allow-Hedaers：服务器端允许的Headers Access-Control-Allow-Methods：服务器端允许的请求方法 Acees-Control-Allow-Origin：服务器端允许的请求Origin头部 Content-Type：服务器返回的实体内容类型 Data：数据从服务器发起的时间 Cache-Control：告诉浏览器或其他用户，什么环境可以安全的缓存文档 Last-Modified：请求资源的最后修改时间 Expires：文档的过期时间，删除缓存 Max-age：客户端的本地资源的缓存时间(单位-秒)，开启了Cache-Contral后有效 ETag：请求标量的实体标签的当前值 Set-Cookie：设置和页面关联的cookie，服务器通过整个头部把cookie传给客户端 Keep-Alive：客户端有keep-alive，服务端也会响应（timeout=38） Server：服务器的一些相关信息 ``` 请求头部和响应头部是彼此匹配分析的。 最常见的： 请求头部的 Accept 要和响应头部的 Content-Type 进行匹配，否则会报错。 #### 其实我在整理之前一直在想为什么请求头部也有「Content-Type」，那为什么不是它和响应头部的「Content-Type」匹配？ 后来，我整理的时候发现，「Content-Type」是实体头部，指的是：「发送端（可以使客户端，也可以是服务端），用来表明发送信息的文档类型的」，也就是说他是发送性质的，「Accept」是接受性质，so 请求头部的「Accept」和响应头部的「Cotent-Type」匹配的。 #### 举栗子 造成跨域问题，往往是因为请求头部「Origin」要匹配响应头部的「Access-Control-Allow-Origin」，一旦匹配失败，则会报跨域错误。 在使用缓存时，请求头部的 If-Modified-Since、If-None-Match 分别和响应头部的 Last-Modified、ETag 对应 ### 什么是实体头？ ![image](https://ws2.sinaimg.cn/large/006tKfTcgy1g07d19zojoj30h00abmxi.jpg) > 可以理解为「实体信息」的头部 ### 什么是实体信息？ > 消息实体分为响应实体、请求实体 在 http 请求中，会将一些需要的参数放入，你比如 POST 请求。 实体信息中可以放入参数（data=ab&query=123），也可以直接通过表单对象（Form Data 对象，上传时可以带参数、文件、二进制流） 而 http 响应时候，服务端就会返回实体信息（没错，就是 reponse） 一般的接口请求，实体信息就是 JSON 格式的数据，然而接口返回的可以使 JSON 格式的数据也可以使 html，然后通过 JS 渲染 ### 最后讲一下，CRLF > Carriage-Return Line-Feed), 回车换行符 （我也不明白这东西有什么用） 请求头和实体消息之间有一个 CRLF 分隔，响应头部和响应实体之间用一个 CRLF 分隔 一般来说（分隔符类别）: ``` CRLF->Windows-style LF->Unix Style CR->Mac Style ``` 结束下面附上一个 http 请求栗子 ### http 请求报文结构栗子： ![image](https://ws3.sinaimg.cn/large/006tKfTcgy1g07e2c2i61j30gk0m80uo.jpg) #### 再说点什么？ > 今天的内容其实我已经整理的差不多，两天把大牛的 http 请求，简单的整理（抄）了一遍，收获很多，之前一直不懂跨域的原理，以及 request/response 的头部匹配，基本也理解了。从 HTTP 报文结构表面来看至少看出来跨域的问题来自哪里，具体如何解决还需要仔细研究 2019 年 02 月 15 日 20:40:48 袁凯忻]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器如何发起一个完整的HTTP请求(1)]]></title>
    <url>%2F2019%2F02%2F14%2F2019-02-14-http%2F</url>
    <content type="text"><![CDATA[--- title: '浏览器如何发起一个完整的HTTP请求(1)' date: 2019-02-14 21:00:00 +0800 categories: 前端 tag: 笔记 --- ## 浏览器如何发起一个完整的 HTTP 请求？ 答:==应用层==的发送 http 请求，==DNS==将域名解析成 IP，然后到==传输层==通过==三次握手==建立==TCP/IP 请求==，再到==网络层==的 ip 寻址，再到==数据链路层==的封装成帧，最后到==物理层==的利用物理介质传输。 ### 五层因特网协议栈 ``` 1.应用层(dns,http) DNS解析成IP并发送http请求 2.传输层(tcp,udp) 建立tcp连接（三次握手） 3.网络层(IP,ARP) IP寻址 4.数据链路层(PPP) 封装成帧 5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质） ``` ### HTTP > 超文本传输协议，Web 浏览器和 Web 服务器之间的通信，一般基于 TCP/IP 协议 ### DNS > Domain Name System，即域名系统。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53[1]。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。 可以理解为一个工具将域名和 IP 关联了起来，通过让快速访问到 IP,域名查询到 IP。 比较牛逼的网站可能会用 CDN 来进行均衡用户访问负载量。 ### CDN > Content Delivery Network，即内容分发网络。网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。 > 通俗的讲就是在人多的地方放置更多的服务器，当访问量激增，CDN 可以通过全局负载技术将流量平均分配到不同的服务器中，保证流量均很，减少网络拥堵。一般域名查询时会用到 CDN，保证用户访问域名是能获得最快的访问速度 ### 什么是 TCP/IP 协议？ > TCP（传输控制协议）和 IP（网际协议）。 通俗的讲，我们所接触的绝大多数 HTTP 请求都是 TCP/IP 请求。 tcp 将 http 长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输以及断开连接的四次握手。 ### 什么是三次握手、四次握手？ - 三次握手 ``` 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 ``` 通俗的讲 ``` 1.客户端告诉服务端，请求建交 2.服务端告诉客户端，我已经收到请求信息，请确认是否为正确的服务端？ 3.客户端确认，正式建交 ``` - 四次握手 ``` 第一次握手：TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。 第二次握手：服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 第三次握手：服务器关闭客户端的连接，发送一个FIN给客户端。 第四次握手：客户端发回ACK报文确认，并将确认序号设置为收到序号加1。 ``` 通俗的讲 ``` 1.客户端告诉服务器，我要开始和你断交了 2.服务端收到这个断交信息 3.服务器断开连接，并且告诉客户端，服务端断交。 4.客户端获取服务器断交信息，数据通道关闭。 ``` **浏览器对于同一域名的 tcp/ip 并发是有数量限制的，一般是 2~10 个不等，就是 POST/GET 请求在同一域名下请求并发量是有限制的！** ### GET 和 POST 的区别 POST 会发送 2 个 TCP 的包，首先发起预请求，会向服务端发送 headers，如果的到 100 continue,则会发送 data 包，返回数据 GET 只会发送一个 TCP 的包，直接向服务端发送 header 和 data，返回数据。 ### 后台处理流程 ``` 1.一般有的后端是有统一的验证的，如安全拦截，跨域验证 2.如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等） 3.然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等） 4.等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装） 5.然后就是将这个包从后端发送到前端，完成交互 ``` ### http 的报文接口 > 报文接口包含：通用头部，请求/响应头部，请求/响应体 #### 通用头部 ``` Request Url：请求的web服务器地址 Request Method：请求方式（POST/GET/OPTIONS/PUT/DELETED等） Status Code：状态码（10X/404/200) Remote Address： 请求远程的web服务器地址（IP） ``` > 值得注意的是，在存在跨域问题的时候，可能是 method 为 options，状态码为 404/405 等 在这里主要归纳下状态码： ``` 1XX——指示信息，表示请求已接收，继续处理 2XX——成功，表示请求已被成功接收、理解、接受 3XX——重定向，要完成请求必须进行更进一步的操作 4XX——客户端错误，请求有语法错误或请求无法实现 5XX——服务器端错误，服务器未能实现合法的请求 ``` 也就是 4XX 可能是客户端的问题，不单单是服务器端的问题，个人觉得应该优先排除客户端的容器问题（tomcat、iis 等）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[url和正则表达式的学习]]></title>
    <url>%2F2019%2F02%2F13%2F2019-02-13-url%2F</url>
    <content type="text"><![CDATA[--- title: 'url和正则表达式的学习' date: 2019-02-13 21:00:00 +0800 categories: 前端 tag: 笔记 --- ## 浏览器的 URL 的构成 - portocal，协议头，例如：http、ftp 等 - host，主机域名或 IP 地址 - port，端口号 - path，目录路径 - query，即查询参数 - fragment，即#后的 hash 值，一般用来定位到某个位置 > 'http://note.youdao.com/?user=admin&query=123#page=top' = portocal(https://) + host(www.jianshu.com) + port(80) + path(/p/d31f494ad6f5) + query(?user=admin&query=123) + fragment(#page=top) ## window.location - window.location.hostname，返回 web 主机的域名 (segmentfault.com) - window.location.pathname，返回当前页面的路径和文件名(a/119....6) - window.location.port，返回 web 主机的端口 - window.location.portocal，返回所使用的 web 协议（http://） - window.location.assign('https://www.baidu.com")，assign(url)，导航到一个新的页面 - window.location.reload(true) 刷新页面 - window.location.search，获取 url 后额外的数据 ## 如何获取 url 的额外参数与分析正则表达式 ``` function getQueryString(name) { var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i"), r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null; } ``` ### 正则表达式 #### 限定符 | 字符 | 描述 | | ----- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | \* | 匹配前面的子表达式零次或者多次。例如，zo\*能匹配「z」以及「zoo」。等价于{0,}（只要包含「z」、「o」的字符全直接匹配出来） | | + | 匹配前面的子表达式一次或多次，例如，zo+能匹配「zo」以及「zoo」。等价于{0,1}（只要包含「zo」的字符会直接匹配出来） | | ? | 匹配前面的子表达式零次或者多次，例如，「do(es)?」能匹配到「do」，「does」能匹配到「does」，「doxy」中的「do」。（讲包含「do」或者「does」的字符中的「do」、「does」匹配展现出来） | | {n} | n 为一个非负整数。匹配确定的 n 次。例如，「o{2}」不能匹配「Bob」中的「o」，但是能匹配「food」的两个 o（o{2}匹配出至少包含 2 个含有 o 的符合对象） | | {n,} | n 为一个非负整数。至少匹配 n 次。例如，「o{2,}」不能匹配「Bob」中的「o」，但是能匹配「foooooood」的所以的 o（o{2,}匹配出包含大于等于 2 个含有 o 的符合对象），「o{1,}」 等价于 「o+」。「o{0,}」 则等价于 「o\*」。 | | {n,m} | m 和 n 均为非负整数，其中 n]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好]]></title>
    <url>%2F2019%2F02%2F13%2Findex%2F</url>
    <content type="text"><![CDATA[--- title: '你好' date: 2019-02-13 toc: true categories: - 感想 tags: - 感想 --- 最近看到很多大牛开始跳槽，我自己想了想，就现有技术而言，万一公司把我开了，好像自己也没地方可以去了，因为自己太菜了，我之前在网上看到一段话，也送给现在正在踌躇是否继续专研技术还是转管理的人 > 「在公司红利期的成就和业绩并不能代替你现有的成绩，想想自己跳出红利平台和舒适区是否还能继续你的辉煌？」]]></content>
      <categories>
        <category>感想</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
</search>
