<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>「今でもあなたはわたしの光」</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 30 May 2019 10:12:22 +0800</pubDate>
    <lastBuildDate>Thu, 30 May 2019 10:12:22 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>2019-05-29-VUE中的$ref、$on、$emit</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#emiteventnanmeargs&quot; id=&quot;markdown-toc-emiteventnanmeargs&quot;&gt;$emit(eventNanme,[…args])&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ref&quot; id=&quot;markdown-toc-ref&quot;&gt;ref&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ref-1&quot; id=&quot;markdown-toc-ref-1&quot;&gt;$ref&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#适用环境&quot; id=&quot;markdown-toc-适用环境&quot;&gt;适用环境：&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#交互过程&quot; id=&quot;markdown-toc-交互过程&quot;&gt;交互过程&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#oneventcallback&quot; id=&quot;markdown-toc-oneventcallback&quot;&gt;$on(event,callback)&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#示例&quot; id=&quot;markdown-toc-示例&quot;&gt;示例&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#交互过程-1&quot; id=&quot;markdown-toc-交互过程-1&quot;&gt;交互过程：&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;emiteventnanmeargs&quot;&gt;$emit(eventNanme,[…args])&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;参数：
    &lt;ul&gt;
      &lt;li&gt;{string} eventName 触发事件名字&lt;/li&gt;
      &lt;li&gt;[…args] 附加的参数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;用法：
    &lt;ul&gt;
      &lt;li&gt;触发当前实例上的事件。附加参数都会传给监听器回调。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用场景
    &lt;ul&gt;
      &lt;li&gt;子组件调用父组件的方法并且传递数据&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：子组件标签中的时间也不区分大小写要用“-”隔开&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;子组件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;button @click=&quot;emitEvent&quot;&amp;gt;点击我&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  export default {
    data() {
      return {
        msg: &quot;我是子组件中的数据&quot;
      }
    },
    methods: {
      emitEvent(){
        this.$emit('my-event', this.msg)
        //通过按钮的点击事件触发方法，然后用$emit触发一个my-event的自定义方法，传递this.msg数据。
      }
    }
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;父组件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;child-a @my-event=&quot;getMyEvent&quot;&amp;gt;&amp;lt;/child-a&amp;gt;
    &amp;lt;!--父组件中通过监测my-event事件执行一个方法，然后取到子组件中传递过来的值--&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  import ChildA from './components/child.vue'
  export default {
    components: {
      ChildA
    },
    methods: {
      getMyEvent(msg){
          console.log('接收的数据---------&amp;gt;'+msg)//接收的数据---------&amp;gt;我是子组件中的数据
      }
    }
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;交互过程：
    &lt;ul&gt;
      &lt;li&gt;child.vue为子组件，当在child.vue，点击button。&lt;/li&gt;
      &lt;li&gt;触发子组件的「emitEvent」方法&lt;/li&gt;
      &lt;li&gt;在emitEvent方法中执行「this.$emit)(‘my-event’,this.msg)」,调用父组件的「my-event」的方法&lt;/li&gt;
      &lt;li&gt;执行「getMyEvent」方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实际上就是在子组件上操作，但是作用在父组件上。&lt;/p&gt;

&lt;h2 id=&quot;ref&quot;&gt;ref&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;被用来给元素或者子组件注册引用信息。引用信息将会被注册在父组件的$refs对象上。如果在普通的DOM元素上使用，引用指向的就是DOM元素；如果用在子组件上，引用就是指向组件实例：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!-- `vm.$refs.p` will be the DOM node --&amp;gt;
&amp;lt;!-- `vm.$refs.p` 指向这个DOM --&amp;gt;
&amp;lt;p ref=&quot;p&quot;&amp;gt;hello&amp;lt;/p&amp;gt;
&amp;lt;!-- `vm.$refs.child` will be the child component instance --&amp;gt;
&amp;lt;!-- `vm.$refs.child` 指向这个子组件 --&amp;gt;
&amp;lt;child-com ref=&quot;chil&quot;&amp;lt;/child-com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ref 本身是作为渲染结果被创建的，在初始化渲染的时候你不能访问他们，因为他们还不存在，$refs也不是响应式的，因此你不应该试图用它在模板中做数据绑定。&lt;/p&gt;

&lt;h2 id=&quot;ref-1&quot;&gt;$ref&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;但是我们可以使用$ref在直接访问这个子组件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;适用环境&quot;&gt;适用环境：&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;父组件调用子组件的方法，可以传递数据。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;父组件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;child-a ref=&quot;child&quot;&amp;gt;&amp;lt;/child-a&amp;gt;
    &amp;lt;!--用ref给子组件起个名字--&amp;gt;
    &amp;lt;button @click=&quot;getMyEvent&quot;&amp;gt;点击父组件&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  import ChildA from './components/child.vue'
  export default {
    components: {
      ChildA
    },
    data() {
      return {
        msg: &quot;我是父组件中的数据&quot;
      }
    },
    methods: {
      getMyEvent(){
          this.$refs.child.emitEvent(this.msg);
          //调用子组件的方法，child是上边ref起的名字，emitEvent是子组件的方法。
      }
    }
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;子组件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;button&amp;gt;点击我&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  export default {
    methods: {
      emitEvent(msg){
        console.log('接收的数据---------&amp;gt;'+msg)//接收的数据---------&amp;gt;我是父组件中的数据
      }
    }
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;交互过程&quot;&gt;交互过程&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;绑定「child-a」组件，定义为「child」&lt;/li&gt;
      &lt;li&gt;触发父组件的「getMyEvent」&lt;/li&gt;
      &lt;li&gt;调用子组件的方法，child是上边ref起的名字，emitEvent是子组件的方法。&lt;/li&gt;
      &lt;li&gt;子组件中「emitEvent」方法触发。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;oneventcallback&quot;&gt;$on(event,callback)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;参数：
    &lt;ul&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;{string&lt;/td&gt;
              &lt;td&gt;Array&lt;string&gt;} event&lt;/string&gt;&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;{Funtion} callback&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;用法：
    &lt;ul&gt;
      &lt;li&gt;监听当前示例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所传入事件触发函数的额外参数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;适用环境：
    &lt;ul&gt;
      &lt;li&gt;兄弟组件进行通信&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;示例&quot;&gt;示例&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先创建一个vue的空白实例（兄弟间的桥梁）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;父组件&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;template&amp;gt;
     &amp;lt;div&amp;gt;
      &amp;lt;childa&amp;gt;&amp;lt;/childa&amp;gt;	
      &amp;lt;br /&amp;gt;
      &amp;lt;childb&amp;gt;&amp;lt;/childb&amp;gt;  	
     &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
   import childa from './childa.vue';
   import childb from './childb.vue';
   export default {
   	components:{
   		childa,
   		childb
   	},
   	data(){
   		return {
   			msg:&quot;&quot;
   		}
   	},
   	methods:{
   		
   	}
   }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;子组件A  childa&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;发送方使用 ==$emit== 自定义时间把数据带过去&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;template&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;span&amp;gt;A组件-&amp;gt;&amp;lt;/span&amp;gt;
        &amp;lt;input type=&quot;button&quot; value=&quot;把a组件数据传给b&quot; @click =&quot;send&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;

// 空的组件(兄弟的桥梁)
import vmson from &quot;../../../util/emptyVue&quot;

export default {
    data(){
        return {
            msg:{
            	a:'111',
            	b:'222'
            }
        }
    },
    methods:{
        send:function(){
            vmson.$emit(&quot;aevent&quot;,this.msg)
        }
    }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;子组件 childb&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而接收方通过 ==$on==监听自定义时间的callback接收数据&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;template&amp;gt;
 &amp;lt;div&amp;gt;
    &amp;lt;span&amp;gt;b组件,a传的的数据为-&amp;gt;&amp;lt;/span&amp;gt;
 &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
	  import vmson from &quot;../../../util/emptyVue&quot;
	  export default {
		 data(){
		        return {
		            msg:&quot;&quot;
		        }
		    },
		 mounted(){
		        vmson.$on(&quot;aevent&quot;,(val)=&amp;gt;{
		            //监听事件aevent，回调函数要使用箭头函数;
		            console.log(val);//打印结果：我是a组件的数据
		            this.msg = val;
		        })
		  }
	}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;交互过程-1&quot;&gt;交互过程：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;定义一个父组件，作为A/B子组件的通信桥梁&lt;/li&gt;
  &lt;li&gt;在A组件来中设定一个自定义事件「aevent」&lt;/li&gt;
  &lt;li&gt;在B组件中，通过父组件「vmson」进行监听「aevent」事件的触发，进行回调&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然还有其他API&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1g3j3ej34uaj30jm0jlaah.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 29 May 2019 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/05/29/VUE%E4%B8%AD%E7%9A%84ref-on-emit/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/29/VUE%E4%B8%AD%E7%9A%84ref-on-emit/</guid>
        
        <category>笔记</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>2019-03-07-JavaScript的函数式编程(2)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#涵子&quot; id=&quot;markdown-toc-涵子&quot;&gt;涵子&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#什么是涵子&quot; id=&quot;markdown-toc-什么是涵子&quot;&gt;什么是涵子&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#涵子的代码实现&quot; id=&quot;markdown-toc-涵子的代码实现&quot;&gt;涵子的代码实现&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;本文中的知识点，我也不是很懂，比较难理解。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;涵子&quot;&gt;涵子&lt;/h2&gt;

&lt;h3 id=&quot;什么是涵子&quot;&gt;什么是涵子&lt;/h3&gt;

&lt;p&gt;涵子是函数式编程里面最重要的数据类型，也是最基本的运算单位和功能单位。&lt;/p&gt;

&lt;p&gt;它是一种范畴（也是一种容器），包含了值和变形关系。比较特殊的是，它的变形关系可以依次作用于每一个值，&lt;strong&gt;将当前容器变形为另一个容器&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcgy1g0yw1xe4azj30of081q34.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，左侧的圆圈就是一个汉字，表示人名的范畴。外部传入函数f，会转成右边标示早餐的范畴。&lt;/p&gt;

&lt;h3 id=&quot;涵子的代码实现&quot;&gt;涵子的代码实现&lt;/h3&gt;

&lt;p&gt;任何具有map方法的素具结构，都可以当做涵子的实现。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Functor{
    constructor(val){
        this.val=val;
    }
    map(f){
        return new Functor(f(this.val));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在上述代码中，FUnctor是一个涵子，它的map方法接受函数f作为参数，最后返回一个新的涵子，里面包含的值是被f处理过的(f(this.val));&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(new Functor(2)).map(function (a) {
    // 由函数式表面，这是Funtor的return返回执行f(this.val)
    return a + 5; // 7
});

(new Functor(&quot;mynameisKisn&quot;)).map(function (a) {
    return a.toUpperCase(); //MYNAMEISKISN
});

var res = (new Functor('bombs')).map(function (a) {
    return a.concat(' away');
}).map(function (a) {
    console.log(a); // bombs away
    return a.length;
});

console.log(res); // Functor(10),this.val = 10;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的栗子说明，函数式编程里面的运算，都是通过了涵子完成，即运算不直接针对值，而是针对这个值的容器-涵子，涵子本身具有对外接口（map方法），各种函数就是运算符，通过接口接入容器， 引发容器值的变形。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;其实后面还有一些别的涵子介绍，但是我就不对这个方面继续整理了，整体对能力、数据分析、逻辑要求都比较高，我比较菜就不深入学习，主要为了了解基础原理以及基础逻辑即可，后期等我学习完VUE，我会继续深入学习。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 07 Mar 2019 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/03/07/JavaScript%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B(2)/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/03/07/JavaScript%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B(2)/</guid>
        
        <category>笔记</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>2019-03-07-JavaScript的函数式编程(1)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#函数式编程-funtional-programming&quot; id=&quot;markdown-toc-函数式编程-funtional-programming&quot;&gt;函数式编程 Funtional programming&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#什么是范畴论&quot; id=&quot;markdown-toc-什么是范畴论&quot;&gt;什么是范畴论？&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#数学模型&quot; id=&quot;markdown-toc-数学模型&quot;&gt;数学模型&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#范畴与容器&quot; id=&quot;markdown-toc-范畴与容器&quot;&gt;范畴与容器&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#范畴论和函数式编程的关系&quot; id=&quot;markdown-toc-范畴论和函数式编程的关系&quot;&gt;范畴论和函数式编程的关系&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#函数的合成与柯里化&quot; id=&quot;markdown-toc-函数的合成与柯里化&quot;&gt;函数的合成与柯里化&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#合成&quot; id=&quot;markdown-toc-合成&quot;&gt;合成&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#柯里化&quot; id=&quot;markdown-toc-柯里化&quot;&gt;柯里化&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#javascript的class&quot; id=&quot;markdown-toc-javascript的class&quot;&gt;JavaScript的class&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;函数式编程-funtional-programming&quot;&gt;函数式编程 Funtional programming&lt;/h2&gt;

&lt;p&gt;函数式编程是一种编程范式，也就和如何写程序的方法论，属于结构化编程的一中，主要思想是把运算过程尽量写成一系列嵌套的函数调用&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;学习函数式编程需要了解什么？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;了解什么时候范畴论&lt;/li&gt;
  &lt;li&gt;数学模型和范畴之间的关系&lt;/li&gt;
  &lt;li&gt;范畴与函数式编程的关系&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;什么是范畴论&quot;&gt;什么是范畴论？&lt;/h2&gt;

&lt;p&gt;函数式编程的起源，是一门叫范畴论（Caregory Theory）的数学分支&lt;/p&gt;

&lt;p&gt;理解函数式编程的关键，就是理解范畴论。它是一门复杂的数学，认为世界上的所有的概念体系，都可以抽象成一个的‘范畴’&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;范畴就是使用箭头连接的物体&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通俗的讲，就是彼此之间存在某种关系的概念、事务、对象等等，都构成范畴。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1g0ujbfe6jej30hq0dbjrg.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;箭头表示范畴成员之间的关系，正式名称叫做“态射”（morphism）。范畴论任务，同一个范畴的所有成员，就是不同状态的“形变”。通过“态射”就可以从一个成员形变成另一个成员。&lt;/p&gt;

&lt;h3 id=&quot;数学模型&quot;&gt;数学模型&lt;/h3&gt;
&lt;p&gt;既然“范畴“是满足某种形变关系的所有对象，就可以总结出来它的数学模型。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.所有成员是一种集合
2.形变关系是函数
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;也就是说，范畴论是集合论更上层的抽象，简单的理解就是“集合+函数”&lt;/p&gt;

&lt;p&gt;理论上通过函数，就可以从范畴的一个成员，算出其他所有成员&lt;/p&gt;

&lt;h3 id=&quot;范畴与容器&quot;&gt;范畴与容器&lt;/h3&gt;

&lt;p&gt;如果把“范畴”想象成一个容器，里面包含两样东西。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;值（value）
值得变形关系，（函数）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;下面我们来定义一个简单的范畴&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    class Category {
        // 实例化时，传过来的参数
        constructor(a, b, c) {
            this.val = a + b + c;
        }

        addOn(x) {
            return x + 1;
        }
    }

    var a = new Category(12, 3, 4);

    console.log(a); // Category {val: 19}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码中，Category是一个类，也是一个容器，里面包含了一个值(this.val)和一种变形关系(addOne)。该关系就是彼此之间都相差1的数字。&lt;/p&gt;

&lt;h3 id=&quot;范畴论和函数式编程的关系&quot;&gt;范畴论和函数式编程的关系&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;范畴论使用函数，表达范畴之间的关系&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;伴随着范畴论的发展，就发展除了一整套函数的运算方法。方法起初只是适用于数学算法，后来有人将它在计算机上实现了，成为了今天的“函数式编程”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本质上，函数式编程只是范畴论的预算方法，跟数学逻辑、微积分、行列式都是一类东西，都是数学方法，只是正好用它来写程序。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;函数的合成与柯里化&quot;&gt;函数的合成与柯里化&lt;/h2&gt;

&lt;p&gt;函数式编程有2个最基本的运算&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;合成&lt;/li&gt;
  &lt;li&gt;柯里化&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;合成&quot;&gt;合成&lt;/h3&gt;

&lt;p&gt;如果一个值要经过多个函数，才能变成另外一个值，就可以把所有的中间步骤合并成一个函数，叫做“函数的合成”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1g0ujbv9nszj309608swec.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，X和Y之间的变形关系是函数f，Y和Z的变形关系是g，那么X和Z之间的关系，就是g和f的合成函数g·f。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    const compose = function (f, g) {
        return function (x) {
            return f(g(y));
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1g0ujc6qw2fj30m808pdfz.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;函数的合成还必须要满足结合律&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;compose(f,compse(g.h));
// 等同于
compose(compose(f,g),h);
// 等同于
compose(f,g,h);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;柯里化&quot;&gt;柯里化&lt;/h3&gt;
&lt;p&gt;f(x)和g(x)合成为f(g(x)),有一个隐藏的前提，就是f和g都只能接受一个参数。如果接受多个参数，比如f(x,y)和g(a,b,c)，函数合成就很麻烦。
所以需要函数柯里化，把一个多参数的函数，转化为一个单参数的函数；&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &quot;use strict&quot;;

    // 未柯里化
    function add(x, y) {
        return alert(x + y);
    }

    // 柯里化后
    function Xadd(x) {
        return function (y) {
            return alert(x + y);
        }
    }

    Xadd(2)(3);// 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;有了柯里化以后，我们就能做到，所以函数只能接受一个参数。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里面包含了ES6的class、constructor等特性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;javascript的class&quot;&gt;JavaScript的class&lt;/h3&gt;

&lt;p&gt;在ES5的时候，我们编写JavaScript很多时候只能使用构造函数和原型链进行方法属性，实现class的功能&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // ES5环境
    'use strict';
    // Box是一个构造函数
    function Box(val) {
        this.type = 'double';
        this.color = val;
    }
    // 我们通过prototype的方式来添加一条属性
    Box.prototype.hello = function () {
        console.log('hello,' + this.type + &quot;,&quot; + this.color);
    }

    // 对于私有属性（static method），  我们当然不能放在原型链上，我们直接放在构造函数上面。
    Box.fn = function () {
        console.log('static');
    }

    //通过new来创建
    var circle = new Box('red');
    circle.hello(); // hello,double,red
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是在ES6的规范中，可以使用class语法，ES6的class可以看做只是一个语法糖，它绝大部分都可以做到，新的class写法只是让对象原型的写法更加清晰、更想面对对象编程的语法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // es6
    class BoxES6 {
        constructor(val) {
            this.type = 'double';
            this.color = val;
        }
        hello() {
            console.log('hello,' + this.type + ',' + this.color);
        }
    }
    
    //通过new来创建
    var helloBlue = new BoxES6('blue');

    helloBlue.hello(); // hello,double,blue
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 07 Mar 2019 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/03/07/JavaScript%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B(1)/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/03/07/JavaScript%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B(1)/</guid>
        
        <category>笔记</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>2019-03-06-闭包(Closurce)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#什么是闭包&quot; id=&quot;markdown-toc-什么是闭包&quot;&gt;什么是闭包？&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#变量的作用域&quot; id=&quot;markdown-toc-变量的作用域&quot;&gt;变量的作用域&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#如何从外部读取局部变脸&quot; id=&quot;markdown-toc-如何从外部读取局部变脸&quot;&gt;如何从外部读取局部变脸？&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#在函数内部在定义一个函数&quot; id=&quot;markdown-toc-在函数内部在定义一个函数&quot;&gt;在函数内部，在定义一个函数&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#闭包的用途&quot; id=&quot;markdown-toc-闭包的用途&quot;&gt;闭包的用途&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#使用闭包的注意点&quot; id=&quot;markdown-toc-使用闭包的注意点&quot;&gt;使用闭包的注意点&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了&quot; id=&quot;markdown-toc-好了写完了&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-1&quot; id=&quot;markdown-toc-好了写完了-1&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-2&quot; id=&quot;markdown-toc-好了写完了-2&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-3&quot; id=&quot;markdown-toc-好了写完了-3&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-4&quot; id=&quot;markdown-toc-好了写完了-4&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-5&quot; id=&quot;markdown-toc-好了写完了-5&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-6&quot; id=&quot;markdown-toc-好了写完了-6&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-7&quot; id=&quot;markdown-toc-好了写完了-7&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-8&quot; id=&quot;markdown-toc-好了写完了-8&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-9&quot; id=&quot;markdown-toc-好了写完了-9&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-10&quot; id=&quot;markdown-toc-好了写完了-10&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-11&quot; id=&quot;markdown-toc-好了写完了-11&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-12&quot; id=&quot;markdown-toc-好了写完了-12&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-13&quot; id=&quot;markdown-toc-好了写完了-13&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-14&quot; id=&quot;markdown-toc-好了写完了-14&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-15&quot; id=&quot;markdown-toc-好了写完了-15&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-16&quot; id=&quot;markdown-toc-好了写完了-16&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-17&quot; id=&quot;markdown-toc-好了写完了-17&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-18&quot; id=&quot;markdown-toc-好了写完了-18&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-19&quot; id=&quot;markdown-toc-好了写完了-19&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-20&quot; id=&quot;markdown-toc-好了写完了-20&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-21&quot; id=&quot;markdown-toc-好了写完了-21&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-22&quot; id=&quot;markdown-toc-好了写完了-22&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-23&quot; id=&quot;markdown-toc-好了写完了-23&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-24&quot; id=&quot;markdown-toc-好了写完了-24&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-25&quot; id=&quot;markdown-toc-好了写完了-25&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-26&quot; id=&quot;markdown-toc-好了写完了-26&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-27&quot; id=&quot;markdown-toc-好了写完了-27&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-28&quot; id=&quot;markdown-toc-好了写完了-28&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-29&quot; id=&quot;markdown-toc-好了写完了-29&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-30&quot; id=&quot;markdown-toc-好了写完了-30&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-31&quot; id=&quot;markdown-toc-好了写完了-31&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-32&quot; id=&quot;markdown-toc-好了写完了-32&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-33&quot; id=&quot;markdown-toc-好了写完了-33&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-34&quot; id=&quot;markdown-toc-好了写完了-34&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-35&quot; id=&quot;markdown-toc-好了写完了-35&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-36&quot; id=&quot;markdown-toc-好了写完了-36&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-37&quot; id=&quot;markdown-toc-好了写完了-37&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-38&quot; id=&quot;markdown-toc-好了写完了-38&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-39&quot; id=&quot;markdown-toc-好了写完了-39&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-40&quot; id=&quot;markdown-toc-好了写完了-40&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-41&quot; id=&quot;markdown-toc-好了写完了-41&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;什么是闭包&quot;&gt;什么是闭包？&lt;/h2&gt;
&lt;p&gt;闭包就是能够读取其他函数内部变脸的函数。在JavaScript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成「定义在一个函数内部的函数」。本质，闭包是将函数内部和函数外部连接起来的桥梁。&lt;/p&gt;

&lt;h3 id=&quot;变量的作用域&quot;&gt;变量的作用域&lt;/h3&gt;

&lt;p&gt;要了解闭包，首先必须了解JavaScript特殊的变量作用域。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;全局变量&lt;/li&gt;
  &lt;li&gt;局部变量&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = 12345； // 全局变量

function f1(){
    alert(a);
}

f1(); //12345
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是在函数外部自然不能读取函数内部的变量。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function f1(){
    var a = 12345;
}

alert(a); // error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;在函数内部声明变量的时候，一定要使用var，如果不使用，实际上你生命了一个全局变量&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function f1(){
    a = 12345;
}
f1();
alert(n); // 12345
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;如何从外部读取局部变脸&quot;&gt;如何从外部读取局部变脸？&lt;/h2&gt;
&lt;h3 id=&quot;在函数内部在定义一个函数&quot;&gt;在函数内部，在定义一个函数&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function f1(){
    var n = 999;
    function f2(){
        alert(n); // 999
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在代码中，函数f2就被包含在函数f1内部，这是f1内部的所有全局变量，对f2都是可见的。但是反过来不行，f2内部的局部变量，对f1是不可见的。只能子对象一级以及网上寻找所有父对象的变量。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function f1(){
    var n=999;
    function f2(){
        alert(n);
    }
    
    return f2;
}

var res = f1();

res(); // 999
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如上面的代码所示，f2函数就是闭包。&lt;/p&gt;

&lt;h2 id=&quot;闭包的用途&quot;&gt;闭包的用途&lt;/h2&gt;
&lt;p&gt;闭包主要的在&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;可以读取函数内部的变量&lt;/li&gt;
  &lt;li&gt;让这些变脸的值始终保持在内存中&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function f1(){
    var n = 999;
    
    nAdd = function(){
        n += 1;
    }
    
    function f2(){
        alert(n);
    }
    
    return f2;
}

var res = f1();

res(); // 999

nAdd();

res(); // 1000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在上述代码中，res实际上就是闭包f2函数。他一共运行了2次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保持在内存中，并没有在f1调用后被自动清除。&lt;/p&gt;

&lt;p&gt;f1是f2的富含，而f2被赋予了一个全局变脸，这导致f2永远存在内存中，而f2的存在依赖于f1，因此f1也必须始终存在于内存中，不会在调用结束后，被垃圾回收机制回收。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;值得注意&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nAdd = function(){
    n += 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;首先，在nAdd前面没有加&lt;strong&gt;var&lt;/strong&gt;,因此nAdd是一个全局变量，而不是局部棉量，其次nAdd的值是一个匿名函数，而这个匿名函数本身也是个闭包，所以nAdd相当于是一个setter，可以在函数外部对内部的局部变量进行操作。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意！ 「onAdd」这种函数写法，在严格模式（’use strict’）下是会报错的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;使用闭包的注意点&quot;&gt;使用闭包的注意点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;由于闭包会使得函数的变量都被保存在内存中，内存消耗是很严重的，所以不能滥用闭包，否则会造成网页的性能问题，在IE中会导致内存泄漏。解决方法是，在退出函数前，将不使用的局部变量全部删除&lt;/li&gt;
  &lt;li&gt;闭包会在函数外部，改变父函数的内部变量的值。所以，如果你把父函数当做对象使用，把闭包当做他的公用方法，把内部变量当做他的私有属性，必须注意，不能随便改变父函数内部变量的值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;好了写完了&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-1&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-2&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-3&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-4&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-5&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-6&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-7&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-8&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-9&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-10&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-11&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-12&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-13&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-14&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-15&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-16&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-17&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-18&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-19&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-20&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-21&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-22&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-23&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-24&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-25&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-26&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-27&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-28&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-29&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-30&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-31&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-32&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-33&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-34&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-35&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-36&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-37&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-38&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-39&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-40&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-41&quot;&gt;好了写完了&lt;/h4&gt;

&lt;hr /&gt;
&lt;p&gt;再说点？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;今天整理完，感觉还有一些时间，分享下上周看的奥斯卡最佳影片「绿皮书」&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;特别喜欢这句对白&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「如果我不够黑人，也不够白人，又或不够男人，那请你告诉我，托尼，那我到底算是什么人！？」&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从学校踏入社会，也有快三年时间了，接触的人也越来越多。在我三观里，对于男女平权、种族仇恨等等，都比较模糊，我只是一直觉得人不可能存在在中立阶段，更多可能是偏左、右，不管从自然选择、和平演变，我觉得大多数人类更多站在自己的利益面发表自己的言论。&lt;/p&gt;

&lt;p&gt;在我看来，这部电影给我最大的思考就就是Don Shirley在雨中对Tony的歇斯底里的怒吼，为什么人活着就要偏向人群所希望亦或一致认知的生活状态。乃至已经到了Don这种高度学历、地位、教育的人依旧困在自己的思想桎梏。&lt;/p&gt;

&lt;p&gt;我经常告诉自己「可能你改不了世界的现状，也改不了身边的朋友、亲人的环境，至少在自己认知方面觉得可以坚持的事，认真坚持到底。」乃至可能也不够「黑」、不够「白」。&lt;/p&gt;

</description>
        <pubDate>Wed, 06 Mar 2019 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/03/06/%E9%97%AD%E5%8C%85(Closurce)/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/03/06/%E9%97%AD%E5%8C%85(Closurce)/</guid>
        
        <category>笔记</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>2019-03-05-JS的回收机制</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#回收机制&quot; id=&quot;markdown-toc-回收机制&quot;&gt;回收机制&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#什么是内存泄漏&quot; id=&quot;markdown-toc-什么是内存泄漏&quot;&gt;什么是内存泄漏？&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#gc的缺陷&quot; id=&quot;markdown-toc-gc的缺陷&quot;&gt;GC的缺陷&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#gc的优化策略&quot; id=&quot;markdown-toc-gc的优化策略&quot;&gt;GC的优化策略&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#分带回收generation-gc&quot; id=&quot;markdown-toc-分带回收generation-gc&quot;&gt;分带回收（Generation GC）&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#结语&quot; id=&quot;markdown-toc-结语&quot;&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;回收机制&quot;&gt;回收机制&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;JS为了防止内存泄露，会执行回收机制&lt;/p&gt;
  &lt;h3 id=&quot;什么是内存泄漏&quot;&gt;什么是内存泄漏？&lt;/h3&gt;
  &lt;p&gt;当已经不需要某块内存时，内存却还存在。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以，回收机制就是阶段性的不定期去寻找不再使用的变量，并释放他们所指向的内存&lt;/p&gt;

&lt;p&gt;比如如何处理哪些已经执行完毕的函数，如果么有外部应用，则会回收。&lt;/p&gt;

&lt;p&gt;常用的两种垃圾回收规则：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;标记清除&lt;/li&gt;
  &lt;li&gt;引用计数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Javascript引擎基础GC方案是（Simple GC）：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mark and sweep&lt;/strong&gt; —&amp;gt; 标记清楚&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;遍历所以可访问的对象&lt;/li&gt;
  &lt;li&gt;回收已不可访问的对象
比如：
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;当变量进入环境时，例如，在函数中声明一个变量，就将它标记为「进入环境」
从逻辑上来讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用他它们。
而当变量离开环境的时候，则会标记「离开环境」
垃圾回收机在运行的时候会给存储在内存中的所有边浪都加上标记
然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）
而在此之后再被加上标记的变量会将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了
最后垃圾回收期完成内存清除工作，销毁哪些带标记的值，并回收他们所占用的内存空间
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简单的阐述：&lt;/p&gt;

&lt;p&gt;跟踪记录每个值被引用的次数，当一个值被引用时，次数-1，减持时-1，下次垃圾回收器会收回次数为0的值的内存。&lt;/p&gt;

&lt;h3 id=&quot;gc的缺陷&quot;&gt;GC的缺陷&lt;/h3&gt;

&lt;p&gt;出于安全考虑&lt;strong&gt;GC时，停止响应其他操作&lt;/strong&gt;
但是它操作时候在&lt;strong&gt;100ms&lt;/strong&gt;甚至以上&lt;/p&gt;

&lt;p&gt;对于一般应用还可以，但是对于js游戏，动画对连贯性要求比较高的应用，需要另外处理。&lt;/p&gt;

&lt;h3 id=&quot;gc的优化策略&quot;&gt;GC的优化策略&lt;/h3&gt;

&lt;h4 id=&quot;分带回收generation-gc&quot;&gt;分带回收（Generation GC）&lt;/h4&gt;
&lt;p&gt;目的是通过区分「临时」与「持久」对象:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;多回收「临时对象」区（young generation）&lt;/li&gt;
  &lt;li&gt;少回收「持久对象」区（tenured generation）&lt;/li&gt;
  &lt;li&gt;减少每次需遍历的对象，从而减少每次GC的耗时。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;「从输入url到页面渲染」文章已经整理（抄）完了，面对如此复杂的机制，很多地方依旧不理解，明天开始准备从基础慢慢开始学习。&lt;/p&gt;
</description>
        <pubDate>Tue, 05 Mar 2019 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/03/05/JS%E7%9A%84%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/03/05/JS%E7%9A%84%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</guid>
        
        <category>笔记</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>2019-03-04-JS的执行阶段</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#js的执行阶段&quot; id=&quot;markdown-toc-js的执行阶段&quot;&gt;JS的执行阶段&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#执行上下文&quot; id=&quot;markdown-toc-执行上下文&quot;&gt;执行上下文&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#每个执行上下文都有三个重要属性&quot; id=&quot;markdown-toc-每个执行上下文都有三个重要属性&quot;&gt;每个执行上下文都有三个重要属性&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#vo和ao&quot; id=&quot;markdown-toc-vo和ao&quot;&gt;VO和AO&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#作用域链&quot; id=&quot;markdown-toc-作用域链&quot;&gt;作用域链&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#流程简述&quot; id=&quot;markdown-toc-流程简述&quot;&gt;流程简述&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#this指针&quot; id=&quot;markdown-toc-this指针&quot;&gt;this指针&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;js的执行阶段&quot;&gt;JS的执行阶段&lt;/h2&gt;

&lt;p&gt;当解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）&lt;/li&gt;
  &lt;li&gt;VO（变量对象）和AO（活动对象）&lt;/li&gt;
  &lt;li&gt;作用域脸&lt;/li&gt;
  &lt;li&gt;this机制&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;执行上下文&quot;&gt;执行上下文&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;JS有执行山下文&lt;/li&gt;
  &lt;li&gt;浏览器首次载入脚本，它将创建「全局执行上下文」，并亚压入执行栈栈顶（不可以被弹出）&lt;/li&gt;
  &lt;li&gt;然后每进入其他作用域就创建对应的执行上下文并把它压入执行栈的顶部&lt;/li&gt;
  &lt;li&gt;一旦对应的上下文执行完毕，就会从栈顶端弹出，并将上下文控制权交给当前的栈&lt;/li&gt;
  &lt;li&gt;依次进行，直至回到全局执行上下文&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果程序执行完成，被弹出执行栈，然后有没有被应用（没有形成闭包），那么这个函数中用的内存就被垃圾处理自动回收。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1g0qztu4q9vj30cv02fmx2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;每个执行上下文都有三个重要属性&quot;&gt;每个执行上下文都有三个重要属性&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;变量对象（Variable object ， VO）&lt;/li&gt;
  &lt;li&gt;作用域链（Scope chain）&lt;/li&gt;
  &lt;li&gt;this&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1g0qzwz985ij309g06xq2x.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;vo和ao&quot;&gt;VO和AO&lt;/h4&gt;
&lt;p&gt;VO是执行上下文的属性，但是只有全局上下文的变量对象允许通过VO的属性名称来间接访问（因为在全局上下文里，全局对象自身就是变量对象）&lt;/p&gt;

&lt;p&gt;AO（activation object），当函数被调用者激活，AO就被创建了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在函数上下文中：VO === AO
在全局上下文中：VO === this === global
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;总体来说，VO中会存放些变量信息（比如声明的变量，函数，arguments参数等等）&lt;/p&gt;

&lt;h3 id=&quot;作用域链&quot;&gt;作用域链&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;作为执行上下文的一个属性，原理和原型链很相似，作用很重要。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;流程简述&quot;&gt;流程简述&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在函数上下文中，查找一个变量foo
如果函数的VO中找到了，就直接使用
否则去它的父级作用域中（__parent__）找
以此往上级找寻，直到全局上下文中没有找到报错。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1g0r08hdnhcj30650bu0sv.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;this指针&quot;&gt;this指针&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;this是执行上下文环境的一个属性，而不是某个变量对象的属性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因此：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;this是没有一个类似搜寻变量的过程&lt;/li&gt;
  &lt;li&gt;当代码中使用了this，这个this的值就直接从执行上下文中获取了，而不会从作用域链中搜寻&lt;/li&gt;
  &lt;li&gt;this的值在取决中进入上下文时的情况&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举个例子&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var baz = 200;
var bar = {
    baz: 100,
    foo: function() {
        consoloe.log(this.baz)
    }
}

var foo = bar.foo;
// 进入环境： global
foo(); // 200，但是严格环境下会报错，Cannot ready property 'baz' of undefined
// 进入环境：global bar
bar.foo(); // 100
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 04 Mar 2019 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/03/04/JS%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/03/04/JS%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5/</guid>
        
        <category>笔记</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>2019-02-28-JS引擎解析过程-解释阶段</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#js引擎解析过程&quot; id=&quot;markdown-toc-js引擎解析过程&quot;&gt;JS引擎解析过程&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#什么是js引擎&quot; id=&quot;markdown-toc-什么是js引擎&quot;&gt;什么是JS引擎？&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#js的解释阶段&quot; id=&quot;markdown-toc-js的解释阶段&quot;&gt;JS的解释阶段&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#js的预处理阶段&quot; id=&quot;markdown-toc-js的预处理阶段&quot;&gt;JS的预处理阶段&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#分号补全&quot; id=&quot;markdown-toc-分号补全&quot;&gt;分号补全&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;js引擎解析过程&quot;&gt;JS引擎解析过程&lt;/h2&gt;
&lt;h3 id=&quot;什么是js引擎&quot;&gt;什么是JS引擎？&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;JavaScript解析引擎是为「读懂」JavaScript代码，并准确地给出代码运行结果的一段程序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = 1 + 1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;JavaScript引擎所做的事情就是看懂（解析）这段代码，并将a的值变成2&lt;/p&gt;

&lt;h3 id=&quot;js的解释阶段&quot;&gt;JS的解释阶段&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;JS是解释型语言，所以它无需提前编译，而是由解释器实时运行的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;引擎对JS的处理过程：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.读取代码，进行词法分析（Lexical analysis），然后讲代码分解成词元（token）
2.对词元进行语法分析（parsing），然后将代码整理成语法书（syntax tree）
3.使用翻译器（translator），将代码转为字节码（bytecode）
4.使用字节码解释器（bytecode interpreter），讲字节码转为机器码
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;最终计算机执行的就是机器码。
为了提高运行速度，浏览器一般采用即时翻译（JIT-JustIn Time compiler）&lt;/p&gt;

&lt;p&gt;即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编码结果缓存（iniline cache）&lt;/p&gt;

&lt;p&gt;这样会使整个程序的运行速度提升
而且对于不同的浏览器可能策略不同，有的浏览器为了省略了字节码的翻译过程，直接转为机器码（比如chrome的v8）&lt;/p&gt;

&lt;p&gt;总结：核心的JIT编译器可以将源码编译成机器码运行&lt;/p&gt;

&lt;h3 id=&quot;js的预处理阶段&quot;&gt;JS的预处理阶段&lt;/h3&gt;

&lt;p&gt;上述讲的解释器的整体过程，再讲一下在正式执行JS之前，还会有一个预处理阶段&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;变量提升&lt;/li&gt;
  &lt;li&gt;分号补全&lt;/li&gt;
  &lt;li&gt;处理变量冲突&lt;/li&gt;
  &lt;li&gt;···&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;分号补全&quot;&gt;分号补全&lt;/h4&gt;

&lt;p&gt;这个比较简单&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;console.log('a')
console.log('b')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;JS预处理会在后面加上分号，因为JS解释器有一个「Semicolon Insertion」规则，他会按照一定规则，在适当的位置补充分号&lt;/p&gt;

&lt;p&gt;规则（不全）:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;当有换行符的时候（包括含有换行符的多行注释），并且下一句token没有根前面的语法匹配时，自动添加分号。&lt;/li&gt;
  &lt;li&gt;当有}时候，如果缺少分号，会添加分号&lt;/li&gt;
  &lt;li&gt;程序源代码结束是，如果缺少分号，会补分号。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最终&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;console.log('a');
console.log('b');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;举一个反例&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function b() {
    return
    {
        a: 'a'
    };
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可能你想输入的结果是：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{a: 'a'}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;但是由于分号补全机制，最后会变成：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function b(){
    return;
    {
        a:'a'
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;运行以后就是&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;undefined
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;变量提升&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在执行过程中，可能开头没有定义变量或者函数，但是往往并没有报错。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中包括函数提升和变量提升&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a  = 1;
b();
function b(){
    console.log('b');
}

var a;
b();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于变量提升，最终结果,2个b()都会执行，a会被赋值。&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Feb 2019 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/28/JS%E5%BC%95%E6%93%8E%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B-%E8%A7%A3%E9%87%8A%E9%98%B6%E6%AE%B5/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/28/JS%E5%BC%95%E6%93%8E%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B-%E8%A7%A3%E9%87%8A%E9%98%B6%E6%AE%B5/</guid>
        
        <category>笔记</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>2019-02-27-CSS的可视化格式模型(2)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#fc&quot; id=&quot;markdown-toc-fc&quot;&gt;FC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ifcinline-formatting-context&quot; id=&quot;markdown-toc-ifcinline-formatting-context&quot;&gt;IFC（inline Formatting Context）&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ifc规则&quot; id=&quot;markdown-toc-ifc规则&quot;&gt;IFC规则&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#行匡&quot; id=&quot;markdown-toc-行匡&quot;&gt;行匡&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#行框的规则&quot; id=&quot;markdown-toc-行框的规则&quot;&gt;行框的规则&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#总结&quot; id=&quot;markdown-toc-总结&quot;&gt;总结&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#相比较bfc规则ifc可能更加抽奖因为没有那么清晰的规则和触发条件&quot; id=&quot;markdown-toc-相比较bfc规则ifc可能更加抽奖因为没有那么清晰的规则和触发条件&quot;&gt;相比较BFC规则，IFC可能更加抽奖（因为没有那么清晰的规则和触发条件）&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#但是总体来说它就是行内元素自身如何显示以及在框内如何摆放的渲染规则&quot; id=&quot;markdown-toc-但是总体来说它就是行内元素自身如何显示以及在框内如何摆放的渲染规则&quot;&gt;但是总体来说，它就是行内元素自身如何显示以及在框内如何摆放的渲染规则。&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;上一篇忘了说明什么是格式上下文（FC）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;fc&quot;&gt;FC&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Formattinf Context,格式上下文。它定义了框内部的元素渲染规则，比较抽象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;FC像是一个容器，里面内部包含元素。容器可以隔开里面的额元素和外面的元素，保护内部元素被外部元素影响。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意，并不是说所有的框都产生FC，而是符合特定条件才会产生，只有产生了对于的FC后才会应用对应渲染规则&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;ifcinline-formatting-context&quot;&gt;IFC（inline Formatting Context）&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;行内框产生的格式上下文&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;ifc规则&quot;&gt;IFC规则&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在行内格式化上下文中框一个接一个水平排列，七点是包含块的顶部。

水平方向上的margin，border和padding在框之间得以保留

框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐

浮动元素可能会处于包含块的边缘和行款边缘之间

尽管在相同的行内格式胡上下问中的行框通常拥有相同的宽度，他们可能会因为浮动元素缩短了可用宽度，而在宽度上发生变化

同一行内格式化上下文中的行框通常高度不一样（如，一行包含了一个高的图形，而其他行只包含了文本）

当一行中行内宽度和总和小鱼包含他们的行框的宽，他们在水平方向上对齐，取决于「text-align」的属性

空的行内框应该被忽略

及不包含,保留空白符，margrin/padding/border非0的行内元素，以及其他常规流中的内容（比如，图片，inline-blcoks和inline-tables）并且不是以换行结束的行框，
必须被当做零高度行框对待
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;行匡&quot;&gt;行匡&lt;/h3&gt;
&lt;p&gt;包含那些框的长方形区域，会形成一行，叫行框&lt;/p&gt;

&lt;p&gt;行框的宽度由它的包含块和其中的浮动元素决定，高度的确定由行高度计算规则决定&lt;/p&gt;

&lt;h3 id=&quot;行框的规则&quot;&gt;行框的规则&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果几个行内框在水平方向无法放入一个行框内，它们可以分配在两个或者多个行框垂直堆叠的行框内
行框在堆叠时没有垂直方向上的分割且永不重叠
行框的高度总是足够容纳所包含的所有框，不过他可能高于它包含的最高的框
行框的左边接触到其包含快的左边，后边接触到其包含块的右边
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;行内元素总会应用IFC渲染规则&lt;/li&gt;
  &lt;li&gt;行内元素会应用IFC规则渲染，例如「text-align」可以用来居中&lt;/li&gt;
  &lt;li&gt;块框内部，对语文本这类的匿名元素，会产生匿名行框包围，而行框内部就应用IFC渲染规则&lt;/li&gt;
  &lt;li&gt;行内框内部，对于那些行内元素，应该应用IFC渲染规则&lt;/li&gt;
  &lt;li&gt;另外， 「inline-block」，挥着元素外层生成IFC（所以这个元素是可以通过「text-align」来水平居中的），当然它内部则是按照BFC规则渲染&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;相比较bfc规则ifc可能更加抽奖因为没有那么清晰的规则和触发条件&quot;&gt;相比较BFC规则，IFC可能更加抽奖（因为没有那么清晰的规则和触发条件）&lt;/h4&gt;
&lt;h4 id=&quot;但是总体来说它就是行内元素自身如何显示以及在框内如何摆放的渲染规则&quot;&gt;但是总体来说，它就是行内元素自身如何显示以及在框内如何摆放的渲染规则。&lt;/h4&gt;

</description>
        <pubDate>Wed, 27 Feb 2019 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/27/CSS%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B(2)/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/27/CSS%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B(2)/</guid>
        
        <category>笔记</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>2019-02-26-CSS的可视化格式模型</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#css的可视化格式模型&quot; id=&quot;markdown-toc-css的可视化格式模型&quot;&gt;CSS的可视化格式模型&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#简介&quot; id=&quot;markdown-toc-简介&quot;&gt;简介&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#包含快containing-block&quot; id=&quot;markdown-toc-包含快containing-block&quot;&gt;包含快（Containing Block）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#控制框controlling-box&quot; id=&quot;markdown-toc-控制框controlling-box&quot;&gt;控制框（Controlling Box）&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#匿名块框&quot; id=&quot;markdown-toc-匿名块框&quot;&gt;匿名块框&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#行内框&quot; id=&quot;markdown-toc-行内框&quot;&gt;行内框&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#display属性影响&quot; id=&quot;markdown-toc-display属性影响&quot;&gt;display属性影响&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#总结&quot; id=&quot;markdown-toc-总结&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#bfcblock-formatting-context&quot; id=&quot;markdown-toc-bfcblock-formatting-context&quot;&gt;BFC（Block Formatting Context）&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#特点&quot; id=&quot;markdown-toc-特点&quot;&gt;特点：&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#如何触发bfc&quot; id=&quot;markdown-toc-如何触发bfc&quot;&gt;如何触发BFC？&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;css的可视化格式模型&quot;&gt;CSS的可视化格式模型&lt;/h2&gt;
&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CSS中规定每个元素都有自己的盒子模型&lt;/li&gt;
  &lt;li&gt;可视化格式模型则是把这些盒子按照规则摆放到页面上布局&lt;/li&gt;
  &lt;li&gt;盒子模型规定了怎么在页面上布局盒子和盒子之间的相互作用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CSS的可视化格式模型规定了浏览器在页面中如何处理文档树&lt;/p&gt;

&lt;p&gt;其中包括了&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;包含块（Containing Block)
控制框（Controlling Box）
BFC（Block Formatting Context）
IF（Inline Formatting Context）
定位体系
浮动
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;CSS包含了三种定位机制：&lt;strong&gt;普通&lt;/strong&gt;，&lt;strong&gt;浮动&lt;/strong&gt;，&lt;strong&gt;决定定位&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;包含快containing-block&quot;&gt;包含快（Containing Block）&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;一个元素的box的定位尺寸，会与某个矩形框有关，这个框就称之为包含块。元素会为他的子孙元素创建包含块，但是并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通俗的讲，就是定位参考框或者定位左边参考系&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;根元素是最顶端的元素，它没有父节点，它的包含块就是初始包含块&lt;/li&gt;
  &lt;li&gt;static和relative的包含块是由它最近的块级、单元格或者行内块祖先元素的内容框（content）创建的。&lt;/li&gt;
  &lt;li&gt;fixed的包含块是当前的可是窗口&lt;/li&gt;
  &lt;li&gt;absolute的包含块由他最近的position属性为&lt;strong&gt;abosolute&lt;/strong&gt;，&lt;strong&gt;relative&lt;/strong&gt;，&lt;strong&gt;fixed&lt;/strong&gt;的祖先元素创建
    &lt;ul&gt;
      &lt;li&gt;如果其祖先元素是行内元素，则包含块取决于其祖先元素的direction特性&lt;/li&gt;
      &lt;li&gt;如果祖先元素不是行内元素，那么包含块的区域应该为祖先元素的内边距边界&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;direction: 设置文本方向&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;div{
    direction: rtl;
    
    rtl //文本方向从右到左。
    ltl //默认。文本方向从左到右。
    inherit //规定应该从父元素继承 direction 属性的值。
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;控制框controlling-box&quot;&gt;控制框（Controlling Box）&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;块级元素和块框以及行内元素和行框的相关概念&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;块框&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;块级元素会生成一个块框（Block Box），块框会占据一整行，用来包含子box和生成的内容&lt;/li&gt;
  &lt;li&gt;块框同时也是一个块包含框（Containing Box），里面要么只包含块框，要么只能包含行内块（不能混淆），如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;匿名块框&quot;&gt;匿名块框&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;
    Some text
    &amp;lt;p&amp;gt;More text&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;div生成一个块框，包含了另外一个块框p以及文本内容「Sometext」，此时「Some text」文本会被强制加上一个匿名的块框里面，被div生成的块框包含&lt;/p&gt;

&lt;p&gt;如果一个块框在其中包含了另外一个块框，那么我们强迫它只能包含块框，因此其他文本内容生产出来的都是匿名块框&lt;/p&gt;

&lt;h4 id=&quot;行内框&quot;&gt;行内框&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;一个行内元素生成一个行内框&lt;/li&gt;
  &lt;li&gt;行内元素能排在一行，允许左右有其他元素&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于匿名行内框的生成：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;P&amp;gt;Some &amp;lt;EM&amp;gt;emphasized&amp;lt;/EM&amp;gt; text&amp;lt;/P&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;p元素生成一个块框，其中有几个行内框（如EM），以及文本「Some」「text」，此时会专门为这些文本生成匿名行内狂&lt;/p&gt;

&lt;h4 id=&quot;display属性影响&quot;&gt;display属性影响&lt;/h4&gt;

&lt;p&gt;display的几个属性也可以影响不同框的生成：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;block：元素生成一个块框&lt;/li&gt;
  &lt;li&gt;inline：元素生成一个或多个行内框&lt;/li&gt;
  &lt;li&gt;inline-block：元素生成一个行内块级框，行内块级的内部会被当做块级来格式化，因此元素本身会被当做行内框来格式化&lt;/li&gt;
  &lt;li&gt;none：不生成框，不在格式化结构中&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;visibility:hidden 产生一个不可见的框&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;1.如果一个框内有一个块级元素，那么这个框里的内容都会被当做块框来进行格式化，因为只要出现块级元素，就会将里面的内容分块几块，每一块独占一行（出现行内，则用匿名块框包含）
2.如果一个框内，没有任何块级元素，那么这个框里的内容会被当做行内框来格式化，因为里面的内容按照顺序成行的排列&lt;/p&gt;

&lt;h3 id=&quot;bfcblock-formatting-context&quot;&gt;BFC（Block Formatting Context）&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;块级格式化上下文，浮动元素和绝对定位元素，非块级盒子的块级，以及overflow不为「visiable」的块级盒子，都会为他们的内容创建新的BFC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在块级格式化上下文中，每个元素左边与包含块的左边相接触（对于从右到左的格式化，右外边接触右边），即使寸浮动也是如此（所以浮动元素正常会直接贴近它的包含块的左边，与普通元素重合）&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;除非这个元素也创建一个新的BFC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;特点&quot;&gt;特点：&lt;/h4&gt;

&lt;p&gt;1.内部box在垂直防线，一个接一个的放置
2.box的垂直方向由margin决定，属于同一个BFC的两个box间的margin会重叠（这个比较重要）
3.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响外卖的元素。
4.计算BFC的高度时候，浮动元素也会计算（不会浮动坍塌）&lt;/p&gt;

&lt;h4 id=&quot;如何触发bfc&quot;&gt;如何触发BFC？&lt;/h4&gt;
&lt;p&gt;1.根元素
2.float不为none
3.position为absolute或者fixed
4.dispaly为inline-block、flex、inline-flex、table、tablec-cell、table-caption
5.overflow不为visible&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ps:「display:table」，它本身不产生BFC，但是它会产生匿名框（包含display:table-cell的框），而这个匿名框产生BFC&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Tue, 26 Feb 2019 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/26/CSS%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/26/CSS%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B/</guid>
        
        <category>笔记</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>2019-02-21-解析页面流程（3）HTML初始化遇到外链的处理</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#chrome中的调试&quot; id=&quot;markdown-toc-chrome中的调试&quot;&gt;Chrome中的调试&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#资源外链的下载&quot; id=&quot;markdown-toc-资源外链的下载&quot;&gt;资源外链的下载&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#遇到外链时的处理&quot; id=&quot;markdown-toc-遇到外链时的处理&quot;&gt;遇到外链时的处理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#遇到css样式资源&quot; id=&quot;markdown-toc-遇到css样式资源&quot;&gt;遇到CSS样式资源&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#遇到js脚本资源&quot; id=&quot;markdown-toc-遇到js脚本资源&quot;&gt;遇到JS脚本资源&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#domcontentloaded事件和onload事件的区别&quot; id=&quot;markdown-toc-domcontentloaded事件和onload事件的区别&quot;&gt;DOMContentLoaded事件和onload事件的区别&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#遇到img图片类资源&quot; id=&quot;markdown-toc-遇到img图片类资源&quot;&gt;遇到img图片类资源&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;chrome中的调试&quot;&gt;Chrome中的调试&lt;/h2&gt;
&lt;p&gt;Chrome的开发者工具中，Perfromance中可以看到详细的渲染工程
&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcgy1g0ebgvx4h6j30p00c0ab4.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;资源外链的下载&quot;&gt;资源外链的下载&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;在解析html时，会遇到一些资源链接，此时需要进行单独处理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一般情况，静态资源分为几个大类（未全列举）：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CSS样式资源&lt;/li&gt;
  &lt;li&gt;JS脚本资源&lt;/li&gt;
  &lt;li&gt;img图片资源&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;遇到外链时的处理&quot;&gt;遇到外链时的处理&lt;/h4&gt;

&lt;p&gt;当遇到上述外链的时候，会独立开启一个下载线程去下载资源（HTTP1.1）&lt;/p&gt;

&lt;h4 id=&quot;遇到css样式资源&quot;&gt;遇到CSS样式资源&lt;/h4&gt;

&lt;p&gt;CSS资源的处理有几个特点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CSS下载时异步，不会阻塞浏览器构建DOM树&lt;/li&gt;
  &lt;li&gt;但是会阻塞渲染，也就是在构建render时候，会等到css下载解析完毕才会进行。（这与浏览器优化有关，防止css规则不断改变，避免了重复的构建）&lt;/li&gt;
  &lt;li&gt;「media query」声明的CSS是不会阻塞渲染的&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;遇到js脚本资源&quot;&gt;遇到JS脚本资源&lt;/h3&gt;
&lt;p&gt;JS脚本资源的处理有几个特点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会解析HTML&lt;/li&gt;
  &lt;li&gt;浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其他资源（当然也有并发上限），但是虽然脚本可以并行下载，但是解析过程仍然是阻塞的，也即是说必须这个脚本和执行完成后才能继续解析，并行下载只是一个优化操作&lt;/li&gt;
  &lt;li&gt;defer与async，普通德积小本是会阻塞浏览器解析的，但是可以加上defer或者async属性，这样脚本就会变成异步了，可以等待解析结束后执行脚本。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;值得注意的是，defer是延迟执行，async是异步执行&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单的来说：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;「async」是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在onload钱，但是不确定在「DOMContentLoaded」事件的前或者后&lt;/li&gt;
  &lt;li&gt;「defer」是延迟执行，在浏览器看起来的效果像是将脚本放在body后面一样。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;domcontentloaded事件和onload事件的区别&quot;&gt;DOMContentLoaded事件和onload事件的区别&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DOMContentLoaded: 当初始的HTML文档被完全加载和解析后，被触发，无需等待样式表、图像和子框架的加载完成。
onload:仅用于检测一个完全加载的页面（图像、CSS资源等）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;遇到img图片类资源&quot;&gt;遇到img图片类资源&lt;/h4&gt;

&lt;p&gt;遇到图片资源时候，直接是异步下载，不会阻塞解析，下载完成后直接使用图片替换原有SRC&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;html基本整理好了，明天和同事有个聚会，就暂时偷个懒，下周开始整理CSS&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 21 Feb 2019 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/21/%E8%A7%A3%E6%9E%90%E9%A1%B5%E9%9D%A2%E6%B5%81%E7%A8%8B-3-HTML%E5%88%9D%E5%A7%8B%E5%8C%96%E9%81%87%E5%88%B0%E5%A4%96%E9%93%BE%E7%9A%84%E5%A4%84%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/21/%E8%A7%A3%E6%9E%90%E9%A1%B5%E9%9D%A2%E6%B5%81%E7%A8%8B-3-HTML%E5%88%9D%E5%A7%8B%E5%8C%96%E9%81%87%E5%88%B0%E5%A4%96%E9%93%BE%E7%9A%84%E5%A4%84%E7%90%86/</guid>
        
        <category>笔记</category>
        
        
        <category>前端</category>
        
      </item>
    
  </channel>
</rss>
