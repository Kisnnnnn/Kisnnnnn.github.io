<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>「今でもあなたはわたしの光」</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 07 Mar 2019 21:27:55 +0800</pubDate>
    <lastBuildDate>Thu, 07 Mar 2019 21:27:55 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>2019-03-06-闭包(Closurce)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#什么是闭包&quot; id=&quot;markdown-toc-什么是闭包&quot;&gt;什么是闭包？&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#变量的作用域&quot; id=&quot;markdown-toc-变量的作用域&quot;&gt;变量的作用域&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#如何从外部读取局部变脸&quot; id=&quot;markdown-toc-如何从外部读取局部变脸&quot;&gt;如何从外部读取局部变脸？&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#在函数内部在定义一个函数&quot; id=&quot;markdown-toc-在函数内部在定义一个函数&quot;&gt;在函数内部，在定义一个函数&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#闭包的用途&quot; id=&quot;markdown-toc-闭包的用途&quot;&gt;闭包的用途&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#使用闭包的注意点&quot; id=&quot;markdown-toc-使用闭包的注意点&quot;&gt;使用闭包的注意点&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了&quot; id=&quot;markdown-toc-好了写完了&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-1&quot; id=&quot;markdown-toc-好了写完了-1&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-2&quot; id=&quot;markdown-toc-好了写完了-2&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-3&quot; id=&quot;markdown-toc-好了写完了-3&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-4&quot; id=&quot;markdown-toc-好了写完了-4&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-5&quot; id=&quot;markdown-toc-好了写完了-5&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-6&quot; id=&quot;markdown-toc-好了写完了-6&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-7&quot; id=&quot;markdown-toc-好了写完了-7&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-8&quot; id=&quot;markdown-toc-好了写完了-8&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-9&quot; id=&quot;markdown-toc-好了写完了-9&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-10&quot; id=&quot;markdown-toc-好了写完了-10&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-11&quot; id=&quot;markdown-toc-好了写完了-11&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-12&quot; id=&quot;markdown-toc-好了写完了-12&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-13&quot; id=&quot;markdown-toc-好了写完了-13&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-14&quot; id=&quot;markdown-toc-好了写完了-14&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-15&quot; id=&quot;markdown-toc-好了写完了-15&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-16&quot; id=&quot;markdown-toc-好了写完了-16&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-17&quot; id=&quot;markdown-toc-好了写完了-17&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-18&quot; id=&quot;markdown-toc-好了写完了-18&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-19&quot; id=&quot;markdown-toc-好了写完了-19&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-20&quot; id=&quot;markdown-toc-好了写完了-20&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-21&quot; id=&quot;markdown-toc-好了写完了-21&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-22&quot; id=&quot;markdown-toc-好了写完了-22&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-23&quot; id=&quot;markdown-toc-好了写完了-23&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-24&quot; id=&quot;markdown-toc-好了写完了-24&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-25&quot; id=&quot;markdown-toc-好了写完了-25&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-26&quot; id=&quot;markdown-toc-好了写完了-26&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-27&quot; id=&quot;markdown-toc-好了写完了-27&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-28&quot; id=&quot;markdown-toc-好了写完了-28&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-29&quot; id=&quot;markdown-toc-好了写完了-29&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-30&quot; id=&quot;markdown-toc-好了写完了-30&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-31&quot; id=&quot;markdown-toc-好了写完了-31&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-32&quot; id=&quot;markdown-toc-好了写完了-32&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-33&quot; id=&quot;markdown-toc-好了写完了-33&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-34&quot; id=&quot;markdown-toc-好了写完了-34&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-35&quot; id=&quot;markdown-toc-好了写完了-35&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-36&quot; id=&quot;markdown-toc-好了写完了-36&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-37&quot; id=&quot;markdown-toc-好了写完了-37&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-38&quot; id=&quot;markdown-toc-好了写完了-38&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-39&quot; id=&quot;markdown-toc-好了写完了-39&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-40&quot; id=&quot;markdown-toc-好了写完了-40&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#好了写完了-41&quot; id=&quot;markdown-toc-好了写完了-41&quot;&gt;好了写完了&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;什么是闭包&quot;&gt;什么是闭包？&lt;/h2&gt;
&lt;p&gt;闭包就是能够读取其他函数内部变脸的函数。在JavaScript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成「定义在一个函数内部的函数」。本质，闭包是将函数内部和函数外部连接起来的桥梁。&lt;/p&gt;

&lt;h3 id=&quot;变量的作用域&quot;&gt;变量的作用域&lt;/h3&gt;

&lt;p&gt;要了解闭包，首先必须了解JavaScript特殊的变量作用域。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;全局变量&lt;/li&gt;
  &lt;li&gt;局部变量&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = 12345； // 全局变量

function f1(){
    alert(a);
}

f1(); //12345
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是在函数外部自然不能读取函数内部的变量。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function f1(){
    var a = 12345;
}

alert(a); // error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;在函数内部声明变量的时候，一定要使用var，如果不使用，实际上你生命了一个全局变量&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function f1(){
    a = 12345;
}
f1();
alert(n); // 12345
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;如何从外部读取局部变脸&quot;&gt;如何从外部读取局部变脸？&lt;/h2&gt;
&lt;h3 id=&quot;在函数内部在定义一个函数&quot;&gt;在函数内部，在定义一个函数&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function f1(){
    var n = 999;
    function f2(){
        alert(n); // 999
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在代码中，函数f2就被包含在函数f1内部，这是f1内部的所有全局变量，对f2都是可见的。但是反过来不行，f2内部的局部变量，对f1是不可见的。只能子对象一级以及网上寻找所有父对象的变量。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function f1(){
    var n=999;
    function f2(){
        alert(n);
    }
    
    return f2;
}

var res = f1();

res(); // 999
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如上面的代码所示，f2函数就是闭包。&lt;/p&gt;

&lt;h2 id=&quot;闭包的用途&quot;&gt;闭包的用途&lt;/h2&gt;
&lt;p&gt;闭包主要的在&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;可以读取函数内部的变量&lt;/li&gt;
  &lt;li&gt;让这些变脸的值始终保持在内存中&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function f1(){
    var n = 999;
    
    nAdd = function(){
        n += 1;
    }
    
    function f2(){
        alert(n);
    }
    
    return f2;
}

var res = f1();

res(); // 999

nAdd();

res(); // 1000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在上述代码中，res实际上就是闭包f2函数。他一共运行了2次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保持在内存中，并没有在f1调用后被自动清除。&lt;/p&gt;

&lt;p&gt;f1是f2的富含，而f2被赋予了一个全局变脸，这导致f2永远存在内存中，而f2的存在依赖于f1，因此f1也必须始终存在于内存中，不会在调用结束后，被垃圾回收机制回收。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;值得注意&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nAdd = function(){
    n += 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;首先，在nAdd前面没有加&lt;strong&gt;var&lt;/strong&gt;,因此nAdd是一个全局变量，而不是局部棉量，其次nAdd的值是一个匿名函数，而这个匿名函数本身也是个闭包，所以nAdd相当于是一个setter，可以在函数外部对内部的局部变量进行操作。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意！ 「onAdd」这种函数写法，在严格模式（’use strict’）下是会报错的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;使用闭包的注意点&quot;&gt;使用闭包的注意点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;由于闭包会使得函数的变量都被保存在内存中，内存消耗是很严重的，所以不能滥用闭包，否则会造成网页的性能问题，在IE中会导致内存泄漏。解决方法是，在退出函数前，将不使用的局部变量全部删除&lt;/li&gt;
  &lt;li&gt;闭包会在函数外部，改变父函数的内部变量的值。所以，如果你把父函数当做对象使用，把闭包当做他的公用方法，把内部变量当做他的私有属性，必须注意，不能随便改变父函数内部变量的值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;好了写完了&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-1&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-2&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-3&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-4&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-5&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-6&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-7&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-8&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-9&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-10&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-11&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-12&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-13&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-14&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-15&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-16&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-17&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-18&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-19&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-20&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-21&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-22&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-23&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-24&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-25&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-26&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-27&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-28&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-29&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-30&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-31&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-32&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-33&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-34&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-35&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-36&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-37&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-38&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-39&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-40&quot;&gt;好了写完了&lt;/h4&gt;
&lt;h4 id=&quot;好了写完了-41&quot;&gt;好了写完了&lt;/h4&gt;

&lt;hr /&gt;
&lt;p&gt;再说点？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;今天整理完，感觉还有一些时间，分享下上周看的奥斯卡最佳影片「绿皮书」&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;特别喜欢这句对白&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;「如果我不够黑人，也不够白人，又或不够男人，那请你告诉我，托尼，那我到底算是什么人！？」&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从学校踏入社会，也有快三年时间了，接触的人也越来越多。在我三观里，对于男女平权、种族仇恨等等，都比较模糊，我只是一直觉得人不可能存在在中立阶段，更多可能是偏左、右，不管从自然选择、和平演变，我觉得大多数人类更多站在自己的利益面发表自己的言论。&lt;/p&gt;

&lt;p&gt;在我看来，这部电影给我最大的思考就就是Don Shirley在雨中对Tony的歇斯底里的怒吼，为什么人活着就要偏向人群所希望亦或一致认知的生活状态。乃至已经到了Don这种高度学历、地位、教育的人依旧困在自己的思想桎梏。&lt;/p&gt;

&lt;p&gt;我经常告诉自己「可能你改不了世界的现状，也改不了身边的朋友、亲人的环境，至少在自己认知方面觉得可以坚持的事，认真坚持到底。」乃至可能也不够「黑」、不够「白」。&lt;/p&gt;

</description>
        <pubDate>Wed, 06 Mar 2019 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/03/06/%E9%97%AD%E5%8C%85(Closurce)/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/03/06/%E9%97%AD%E5%8C%85(Closurce)/</guid>
        
        <category>笔记</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>2019-03-05-JS的回收机制</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#回收机制&quot; id=&quot;markdown-toc-回收机制&quot;&gt;回收机制&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#什么是内存泄漏&quot; id=&quot;markdown-toc-什么是内存泄漏&quot;&gt;什么是内存泄漏？&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#gc的缺陷&quot; id=&quot;markdown-toc-gc的缺陷&quot;&gt;GC的缺陷&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#gc的优化策略&quot; id=&quot;markdown-toc-gc的优化策略&quot;&gt;GC的优化策略&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#分带回收generation-gc&quot; id=&quot;markdown-toc-分带回收generation-gc&quot;&gt;分带回收（Generation GC）&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#结语&quot; id=&quot;markdown-toc-结语&quot;&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;回收机制&quot;&gt;回收机制&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;JS为了防止内存泄露，会执行回收机制&lt;/p&gt;
  &lt;h3 id=&quot;什么是内存泄漏&quot;&gt;什么是内存泄漏？&lt;/h3&gt;
  &lt;p&gt;当已经不需要某块内存时，内存却还存在。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以，回收机制就是阶段性的不定期去寻找不再使用的变量，并释放他们所指向的内存&lt;/p&gt;

&lt;p&gt;比如如何处理哪些已经执行完毕的函数，如果么有外部应用，则会回收。&lt;/p&gt;

&lt;p&gt;常用的两种垃圾回收规则：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;标记清除&lt;/li&gt;
  &lt;li&gt;引用计数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Javascript引擎基础GC方案是（Simple GC）：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mark and sweep&lt;/strong&gt; —&amp;gt; 标记清楚&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;遍历所以可访问的对象&lt;/li&gt;
  &lt;li&gt;回收已不可访问的对象
比如：
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;当变量进入环境时，例如，在函数中声明一个变量，就将它标记为「进入环境」
从逻辑上来讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用他它们。
而当变量离开环境的时候，则会标记「离开环境」
垃圾回收机在运行的时候会给存储在内存中的所有边浪都加上标记
然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）
而在此之后再被加上标记的变量会将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了
最后垃圾回收期完成内存清除工作，销毁哪些带标记的值，并回收他们所占用的内存空间
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简单的阐述：&lt;/p&gt;

&lt;p&gt;跟踪记录每个值被引用的次数，当一个值被引用时，次数-1，减持时-1，下次垃圾回收器会收回次数为0的值的内存。&lt;/p&gt;

&lt;h3 id=&quot;gc的缺陷&quot;&gt;GC的缺陷&lt;/h3&gt;

&lt;p&gt;出于安全考虑&lt;strong&gt;GC时，停止响应其他操作&lt;/strong&gt;
但是它操作时候在&lt;strong&gt;100ms&lt;/strong&gt;甚至以上&lt;/p&gt;

&lt;p&gt;对于一般应用还可以，但是对于js游戏，动画对连贯性要求比较高的应用，需要另外处理。&lt;/p&gt;

&lt;h3 id=&quot;gc的优化策略&quot;&gt;GC的优化策略&lt;/h3&gt;

&lt;h4 id=&quot;分带回收generation-gc&quot;&gt;分带回收（Generation GC）&lt;/h4&gt;
&lt;p&gt;目的是通过区分「临时」与「持久」对象:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;多回收「临时对象」区（young generation）&lt;/li&gt;
  &lt;li&gt;少回收「持久对象」区（tenured generation）&lt;/li&gt;
  &lt;li&gt;减少每次需遍历的对象，从而减少每次GC的耗时。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;「从输入url到页面渲染」文章已经整理（抄）完了，面对如此复杂的机制，很多地方依旧不理解，明天开始准备从基础慢慢开始学习。&lt;/p&gt;
</description>
        <pubDate>Tue, 05 Mar 2019 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/03/05/JS%E7%9A%84%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/03/05/JS%E7%9A%84%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</guid>
        
        <category>笔记</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>2019-03-04-JS的执行阶段</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#js的执行阶段&quot; id=&quot;markdown-toc-js的执行阶段&quot;&gt;JS的执行阶段&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#执行上下文&quot; id=&quot;markdown-toc-执行上下文&quot;&gt;执行上下文&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#每个执行上下文都有三个重要属性&quot; id=&quot;markdown-toc-每个执行上下文都有三个重要属性&quot;&gt;每个执行上下文都有三个重要属性&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#vo和ao&quot; id=&quot;markdown-toc-vo和ao&quot;&gt;VO和AO&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#作用域链&quot; id=&quot;markdown-toc-作用域链&quot;&gt;作用域链&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#流程简述&quot; id=&quot;markdown-toc-流程简述&quot;&gt;流程简述&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#this指针&quot; id=&quot;markdown-toc-this指针&quot;&gt;this指针&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;js的执行阶段&quot;&gt;JS的执行阶段&lt;/h2&gt;

&lt;p&gt;当解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）&lt;/li&gt;
  &lt;li&gt;VO（变量对象）和AO（活动对象）&lt;/li&gt;
  &lt;li&gt;作用域脸&lt;/li&gt;
  &lt;li&gt;this机制&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;执行上下文&quot;&gt;执行上下文&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;JS有执行山下文&lt;/li&gt;
  &lt;li&gt;浏览器首次载入脚本，它将创建「全局执行上下文」，并亚压入执行栈栈顶（不可以被弹出）&lt;/li&gt;
  &lt;li&gt;然后每进入其他作用域就创建对应的执行上下文并把它压入执行栈的顶部&lt;/li&gt;
  &lt;li&gt;一旦对应的上下文执行完毕，就会从栈顶端弹出，并将上下文控制权交给当前的栈&lt;/li&gt;
  &lt;li&gt;依次进行，直至回到全局执行上下文&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果程序执行完成，被弹出执行栈，然后有没有被应用（没有形成闭包），那么这个函数中用的内存就被垃圾处理自动回收。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1g0qztu4q9vj30cv02fmx2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;每个执行上下文都有三个重要属性&quot;&gt;每个执行上下文都有三个重要属性&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;变量对象（Variable object ， VO）&lt;/li&gt;
  &lt;li&gt;作用域链（Scope chain）&lt;/li&gt;
  &lt;li&gt;this&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1g0qzwz985ij309g06xq2x.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;vo和ao&quot;&gt;VO和AO&lt;/h4&gt;
&lt;p&gt;VO是执行上下文的属性，但是只有全局上下文的变量对象允许通过VO的属性名称来间接访问（因为在全局上下文里，全局对象自身就是变量对象）&lt;/p&gt;

&lt;p&gt;AO（activation object），当函数被调用者激活，AO就被创建了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在函数上下文中：VO === AO
在全局上下文中：VO === this === global
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;总体来说，VO中会存放些变量信息（比如声明的变量，函数，arguments参数等等）&lt;/p&gt;

&lt;h3 id=&quot;作用域链&quot;&gt;作用域链&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;作为执行上下文的一个属性，原理和原型链很相似，作用很重要。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;流程简述&quot;&gt;流程简述&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在函数上下文中，查找一个变量foo
如果函数的VO中找到了，就直接使用
否则去它的父级作用域中（__parent__）找
以此往上级找寻，直到全局上下文中没有找到报错。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1g0r08hdnhcj30650bu0sv.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;this指针&quot;&gt;this指针&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;this是执行上下文环境的一个属性，而不是某个变量对象的属性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因此：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;this是没有一个类似搜寻变量的过程&lt;/li&gt;
  &lt;li&gt;当代码中使用了this，这个this的值就直接从执行上下文中获取了，而不会从作用域链中搜寻&lt;/li&gt;
  &lt;li&gt;this的值在取决中进入上下文时的情况&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举个例子&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var baz = 200;
var bar = {
    baz: 100,
    foo: function() {
        consoloe.log(this.baz)
    }
}

var foo = bar.foo;
// 进入环境： global
foo(); // 200，但是严格环境下会报错，Cannot ready property 'baz' of undefined
// 进入环境：global bar
bar.foo(); // 100
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 04 Mar 2019 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/03/04/JS%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/03/04/JS%E7%9A%84%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5/</guid>
        
        <category>笔记</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>2019-02-28-JS引擎解析过程-解释阶段</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#js引擎解析过程&quot; id=&quot;markdown-toc-js引擎解析过程&quot;&gt;JS引擎解析过程&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#什么是js引擎&quot; id=&quot;markdown-toc-什么是js引擎&quot;&gt;什么是JS引擎？&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#js的解释阶段&quot; id=&quot;markdown-toc-js的解释阶段&quot;&gt;JS的解释阶段&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#js的预处理阶段&quot; id=&quot;markdown-toc-js的预处理阶段&quot;&gt;JS的预处理阶段&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#分号补全&quot; id=&quot;markdown-toc-分号补全&quot;&gt;分号补全&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;js引擎解析过程&quot;&gt;JS引擎解析过程&lt;/h2&gt;
&lt;h3 id=&quot;什么是js引擎&quot;&gt;什么是JS引擎？&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;JavaScript解析引擎是为「读懂」JavaScript代码，并准确地给出代码运行结果的一段程序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = 1 + 1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;JavaScript引擎所做的事情就是看懂（解析）这段代码，并将a的值变成2&lt;/p&gt;

&lt;h3 id=&quot;js的解释阶段&quot;&gt;JS的解释阶段&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;JS是解释型语言，所以它无需提前编译，而是由解释器实时运行的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;引擎对JS的处理过程：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.读取代码，进行词法分析（Lexical analysis），然后讲代码分解成词元（token）
2.对词元进行语法分析（parsing），然后将代码整理成语法书（syntax tree）
3.使用翻译器（translator），将代码转为字节码（bytecode）
4.使用字节码解释器（bytecode interpreter），讲字节码转为机器码
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;最终计算机执行的就是机器码。
为了提高运行速度，浏览器一般采用即时翻译（JIT-JustIn Time compiler）&lt;/p&gt;

&lt;p&gt;即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编码结果缓存（iniline cache）&lt;/p&gt;

&lt;p&gt;这样会使整个程序的运行速度提升
而且对于不同的浏览器可能策略不同，有的浏览器为了省略了字节码的翻译过程，直接转为机器码（比如chrome的v8）&lt;/p&gt;

&lt;p&gt;总结：核心的JIT编译器可以将源码编译成机器码运行&lt;/p&gt;

&lt;h3 id=&quot;js的预处理阶段&quot;&gt;JS的预处理阶段&lt;/h3&gt;

&lt;p&gt;上述讲的解释器的整体过程，再讲一下在正式执行JS之前，还会有一个预处理阶段&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;变量提升&lt;/li&gt;
  &lt;li&gt;分号补全&lt;/li&gt;
  &lt;li&gt;处理变量冲突&lt;/li&gt;
  &lt;li&gt;···&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;分号补全&quot;&gt;分号补全&lt;/h4&gt;

&lt;p&gt;这个比较简单&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;console.log('a')
console.log('b')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;JS预处理会在后面加上分号，因为JS解释器有一个「Semicolon Insertion」规则，他会按照一定规则，在适当的位置补充分号&lt;/p&gt;

&lt;p&gt;规则（不全）:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;当有换行符的时候（包括含有换行符的多行注释），并且下一句token没有根前面的语法匹配时，自动添加分号。&lt;/li&gt;
  &lt;li&gt;当有}时候，如果缺少分号，会添加分号&lt;/li&gt;
  &lt;li&gt;程序源代码结束是，如果缺少分号，会补分号。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最终&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;console.log('a');
console.log('b');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;举一个反例&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function b() {
    return
    {
        a: 'a'
    };
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可能你想输入的结果是：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{a: 'a'}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;但是由于分号补全机制，最后会变成：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function b(){
    return;
    {
        a:'a'
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;运行以后就是&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;undefined
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;变量提升&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在执行过程中，可能开头没有定义变量或者函数，但是往往并没有报错。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中包括函数提升和变量提升&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a  = 1;
b();
function b(){
    console.log('b');
}

var a;
b();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于变量提升，最终结果,2个b()都会执行，a会被赋值。&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Feb 2019 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/28/JS%E5%BC%95%E6%93%8E%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B-%E8%A7%A3%E9%87%8A%E9%98%B6%E6%AE%B5/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/28/JS%E5%BC%95%E6%93%8E%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B-%E8%A7%A3%E9%87%8A%E9%98%B6%E6%AE%B5/</guid>
        
        <category>笔记</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>2019-02-27-CSS的可视化格式模型(2)</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#fc&quot; id=&quot;markdown-toc-fc&quot;&gt;FC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ifcinline-formatting-context&quot; id=&quot;markdown-toc-ifcinline-formatting-context&quot;&gt;IFC（inline Formatting Context）&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ifc规则&quot; id=&quot;markdown-toc-ifc规则&quot;&gt;IFC规则&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#行匡&quot; id=&quot;markdown-toc-行匡&quot;&gt;行匡&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#行框的规则&quot; id=&quot;markdown-toc-行框的规则&quot;&gt;行框的规则&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#总结&quot; id=&quot;markdown-toc-总结&quot;&gt;总结&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#相比较bfc规则ifc可能更加抽奖因为没有那么清晰的规则和触发条件&quot; id=&quot;markdown-toc-相比较bfc规则ifc可能更加抽奖因为没有那么清晰的规则和触发条件&quot;&gt;相比较BFC规则，IFC可能更加抽奖（因为没有那么清晰的规则和触发条件）&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#但是总体来说它就是行内元素自身如何显示以及在框内如何摆放的渲染规则&quot; id=&quot;markdown-toc-但是总体来说它就是行内元素自身如何显示以及在框内如何摆放的渲染规则&quot;&gt;但是总体来说，它就是行内元素自身如何显示以及在框内如何摆放的渲染规则。&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;上一篇忘了说明什么是格式上下文（FC）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;fc&quot;&gt;FC&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Formattinf Context,格式上下文。它定义了框内部的元素渲染规则，比较抽象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;FC像是一个容器，里面内部包含元素。容器可以隔开里面的额元素和外面的元素，保护内部元素被外部元素影响。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意，并不是说所有的框都产生FC，而是符合特定条件才会产生，只有产生了对于的FC后才会应用对应渲染规则&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;ifcinline-formatting-context&quot;&gt;IFC（inline Formatting Context）&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;行内框产生的格式上下文&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;ifc规则&quot;&gt;IFC规则&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在行内格式化上下文中框一个接一个水平排列，七点是包含块的顶部。

水平方向上的margin，border和padding在框之间得以保留

框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐

浮动元素可能会处于包含块的边缘和行款边缘之间

尽管在相同的行内格式胡上下问中的行框通常拥有相同的宽度，他们可能会因为浮动元素缩短了可用宽度，而在宽度上发生变化

同一行内格式化上下文中的行框通常高度不一样（如，一行包含了一个高的图形，而其他行只包含了文本）

当一行中行内宽度和总和小鱼包含他们的行框的宽，他们在水平方向上对齐，取决于「text-align」的属性

空的行内框应该被忽略

及不包含,保留空白符，margrin/padding/border非0的行内元素，以及其他常规流中的内容（比如，图片，inline-blcoks和inline-tables）并且不是以换行结束的行框，
必须被当做零高度行框对待
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;行匡&quot;&gt;行匡&lt;/h3&gt;
&lt;p&gt;包含那些框的长方形区域，会形成一行，叫行框&lt;/p&gt;

&lt;p&gt;行框的宽度由它的包含块和其中的浮动元素决定，高度的确定由行高度计算规则决定&lt;/p&gt;

&lt;h3 id=&quot;行框的规则&quot;&gt;行框的规则&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果几个行内框在水平方向无法放入一个行框内，它们可以分配在两个或者多个行框垂直堆叠的行框内
行框在堆叠时没有垂直方向上的分割且永不重叠
行框的高度总是足够容纳所包含的所有框，不过他可能高于它包含的最高的框
行框的左边接触到其包含快的左边，后边接触到其包含块的右边
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;行内元素总会应用IFC渲染规则&lt;/li&gt;
  &lt;li&gt;行内元素会应用IFC规则渲染，例如「text-align」可以用来居中&lt;/li&gt;
  &lt;li&gt;块框内部，对语文本这类的匿名元素，会产生匿名行框包围，而行框内部就应用IFC渲染规则&lt;/li&gt;
  &lt;li&gt;行内框内部，对于那些行内元素，应该应用IFC渲染规则&lt;/li&gt;
  &lt;li&gt;另外， 「inline-block」，挥着元素外层生成IFC（所以这个元素是可以通过「text-align」来水平居中的），当然它内部则是按照BFC规则渲染&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;相比较bfc规则ifc可能更加抽奖因为没有那么清晰的规则和触发条件&quot;&gt;相比较BFC规则，IFC可能更加抽奖（因为没有那么清晰的规则和触发条件）&lt;/h4&gt;
&lt;h4 id=&quot;但是总体来说它就是行内元素自身如何显示以及在框内如何摆放的渲染规则&quot;&gt;但是总体来说，它就是行内元素自身如何显示以及在框内如何摆放的渲染规则。&lt;/h4&gt;

</description>
        <pubDate>Wed, 27 Feb 2019 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/27/CSS%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B(2)/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/27/CSS%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B(2)/</guid>
        
        <category>笔记</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>2019-02-26-CSS的可视化格式模型</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#css的可视化格式模型&quot; id=&quot;markdown-toc-css的可视化格式模型&quot;&gt;CSS的可视化格式模型&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#简介&quot; id=&quot;markdown-toc-简介&quot;&gt;简介&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#包含快containing-block&quot; id=&quot;markdown-toc-包含快containing-block&quot;&gt;包含快（Containing Block）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#控制框controlling-box&quot; id=&quot;markdown-toc-控制框controlling-box&quot;&gt;控制框（Controlling Box）&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#匿名块框&quot; id=&quot;markdown-toc-匿名块框&quot;&gt;匿名块框&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#行内框&quot; id=&quot;markdown-toc-行内框&quot;&gt;行内框&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#display属性影响&quot; id=&quot;markdown-toc-display属性影响&quot;&gt;display属性影响&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#总结&quot; id=&quot;markdown-toc-总结&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#bfcblock-formatting-context&quot; id=&quot;markdown-toc-bfcblock-formatting-context&quot;&gt;BFC（Block Formatting Context）&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#特点&quot; id=&quot;markdown-toc-特点&quot;&gt;特点：&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#如何触发bfc&quot; id=&quot;markdown-toc-如何触发bfc&quot;&gt;如何触发BFC？&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;css的可视化格式模型&quot;&gt;CSS的可视化格式模型&lt;/h2&gt;
&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CSS中规定每个元素都有自己的盒子模型&lt;/li&gt;
  &lt;li&gt;可视化格式模型则是把这些盒子按照规则摆放到页面上布局&lt;/li&gt;
  &lt;li&gt;盒子模型规定了怎么在页面上布局盒子和盒子之间的相互作用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CSS的可视化格式模型规定了浏览器在页面中如何处理文档树&lt;/p&gt;

&lt;p&gt;其中包括了&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;包含块（Containing Block)
控制框（Controlling Box）
BFC（Block Formatting Context）
IF（Inline Formatting Context）
定位体系
浮动
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;CSS包含了三种定位机制：&lt;strong&gt;普通&lt;/strong&gt;，&lt;strong&gt;浮动&lt;/strong&gt;，&lt;strong&gt;决定定位&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;包含快containing-block&quot;&gt;包含快（Containing Block）&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;一个元素的box的定位尺寸，会与某个矩形框有关，这个框就称之为包含块。元素会为他的子孙元素创建包含块，但是并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通俗的讲，就是定位参考框或者定位左边参考系&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;根元素是最顶端的元素，它没有父节点，它的包含块就是初始包含块&lt;/li&gt;
  &lt;li&gt;static和relative的包含块是由它最近的块级、单元格或者行内块祖先元素的内容框（content）创建的。&lt;/li&gt;
  &lt;li&gt;fixed的包含块是当前的可是窗口&lt;/li&gt;
  &lt;li&gt;absolute的包含块由他最近的position属性为&lt;strong&gt;abosolute&lt;/strong&gt;，&lt;strong&gt;relative&lt;/strong&gt;，&lt;strong&gt;fixed&lt;/strong&gt;的祖先元素创建
    &lt;ul&gt;
      &lt;li&gt;如果其祖先元素是行内元素，则包含块取决于其祖先元素的direction特性&lt;/li&gt;
      &lt;li&gt;如果祖先元素不是行内元素，那么包含块的区域应该为祖先元素的内边距边界&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;direction: 设置文本方向&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;div{
    direction: rtl;
    
    rtl //文本方向从右到左。
    ltl //默认。文本方向从左到右。
    inherit //规定应该从父元素继承 direction 属性的值。
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;控制框controlling-box&quot;&gt;控制框（Controlling Box）&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;块级元素和块框以及行内元素和行框的相关概念&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;块框&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;块级元素会生成一个块框（Block Box），块框会占据一整行，用来包含子box和生成的内容&lt;/li&gt;
  &lt;li&gt;块框同时也是一个块包含框（Containing Box），里面要么只包含块框，要么只能包含行内块（不能混淆），如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;匿名块框&quot;&gt;匿名块框&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;
    Some text
    &amp;lt;p&amp;gt;More text&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;div生成一个块框，包含了另外一个块框p以及文本内容「Sometext」，此时「Some text」文本会被强制加上一个匿名的块框里面，被div生成的块框包含&lt;/p&gt;

&lt;p&gt;如果一个块框在其中包含了另外一个块框，那么我们强迫它只能包含块框，因此其他文本内容生产出来的都是匿名块框&lt;/p&gt;

&lt;h4 id=&quot;行内框&quot;&gt;行内框&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;一个行内元素生成一个行内框&lt;/li&gt;
  &lt;li&gt;行内元素能排在一行，允许左右有其他元素&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于匿名行内框的生成：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;P&amp;gt;Some &amp;lt;EM&amp;gt;emphasized&amp;lt;/EM&amp;gt; text&amp;lt;/P&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;p元素生成一个块框，其中有几个行内框（如EM），以及文本「Some」「text」，此时会专门为这些文本生成匿名行内狂&lt;/p&gt;

&lt;h4 id=&quot;display属性影响&quot;&gt;display属性影响&lt;/h4&gt;

&lt;p&gt;display的几个属性也可以影响不同框的生成：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;block：元素生成一个块框&lt;/li&gt;
  &lt;li&gt;inline：元素生成一个或多个行内框&lt;/li&gt;
  &lt;li&gt;inline-block：元素生成一个行内块级框，行内块级的内部会被当做块级来格式化，因此元素本身会被当做行内框来格式化&lt;/li&gt;
  &lt;li&gt;none：不生成框，不在格式化结构中&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;visibility:hidden 产生一个不可见的框&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;1.如果一个框内有一个块级元素，那么这个框里的内容都会被当做块框来进行格式化，因为只要出现块级元素，就会将里面的内容分块几块，每一块独占一行（出现行内，则用匿名块框包含）
2.如果一个框内，没有任何块级元素，那么这个框里的内容会被当做行内框来格式化，因为里面的内容按照顺序成行的排列&lt;/p&gt;

&lt;h3 id=&quot;bfcblock-formatting-context&quot;&gt;BFC（Block Formatting Context）&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;块级格式化上下文，浮动元素和绝对定位元素，非块级盒子的块级，以及overflow不为「visiable」的块级盒子，都会为他们的内容创建新的BFC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在块级格式化上下文中，每个元素左边与包含块的左边相接触（对于从右到左的格式化，右外边接触右边），即使寸浮动也是如此（所以浮动元素正常会直接贴近它的包含块的左边，与普通元素重合）&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;除非这个元素也创建一个新的BFC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;特点&quot;&gt;特点：&lt;/h4&gt;

&lt;p&gt;1.内部box在垂直防线，一个接一个的放置
2.box的垂直方向由margin决定，属于同一个BFC的两个box间的margin会重叠（这个比较重要）
3.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响外卖的元素。
4.计算BFC的高度时候，浮动元素也会计算（不会浮动坍塌）&lt;/p&gt;

&lt;h4 id=&quot;如何触发bfc&quot;&gt;如何触发BFC？&lt;/h4&gt;
&lt;p&gt;1.根元素
2.float不为none
3.position为absolute或者fixed
4.dispaly为inline-block、flex、inline-flex、table、tablec-cell、table-caption
5.overflow不为visible&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ps:「display:table」，它本身不产生BFC，但是它会产生匿名框（包含display:table-cell的框），而这个匿名框产生BFC&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Tue, 26 Feb 2019 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/26/CSS%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/26/CSS%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B/</guid>
        
        <category>笔记</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>2019-02-21-解析页面流程（3）HTML初始化遇到外链的处理</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#chrome中的调试&quot; id=&quot;markdown-toc-chrome中的调试&quot;&gt;Chrome中的调试&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#资源外链的下载&quot; id=&quot;markdown-toc-资源外链的下载&quot;&gt;资源外链的下载&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#遇到外链时的处理&quot; id=&quot;markdown-toc-遇到外链时的处理&quot;&gt;遇到外链时的处理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#遇到css样式资源&quot; id=&quot;markdown-toc-遇到css样式资源&quot;&gt;遇到CSS样式资源&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#遇到js脚本资源&quot; id=&quot;markdown-toc-遇到js脚本资源&quot;&gt;遇到JS脚本资源&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#domcontentloaded事件和onload事件的区别&quot; id=&quot;markdown-toc-domcontentloaded事件和onload事件的区别&quot;&gt;DOMContentLoaded事件和onload事件的区别&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#遇到img图片类资源&quot; id=&quot;markdown-toc-遇到img图片类资源&quot;&gt;遇到img图片类资源&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;chrome中的调试&quot;&gt;Chrome中的调试&lt;/h2&gt;
&lt;p&gt;Chrome的开发者工具中，Perfromance中可以看到详细的渲染工程
&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcgy1g0ebgvx4h6j30p00c0ab4.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;资源外链的下载&quot;&gt;资源外链的下载&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;在解析html时，会遇到一些资源链接，此时需要进行单独处理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一般情况，静态资源分为几个大类（未全列举）：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CSS样式资源&lt;/li&gt;
  &lt;li&gt;JS脚本资源&lt;/li&gt;
  &lt;li&gt;img图片资源&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;遇到外链时的处理&quot;&gt;遇到外链时的处理&lt;/h4&gt;

&lt;p&gt;当遇到上述外链的时候，会独立开启一个下载线程去下载资源（HTTP1.1）&lt;/p&gt;

&lt;h4 id=&quot;遇到css样式资源&quot;&gt;遇到CSS样式资源&lt;/h4&gt;

&lt;p&gt;CSS资源的处理有几个特点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CSS下载时异步，不会阻塞浏览器构建DOM树&lt;/li&gt;
  &lt;li&gt;但是会阻塞渲染，也就是在构建render时候，会等到css下载解析完毕才会进行。（这与浏览器优化有关，防止css规则不断改变，避免了重复的构建）&lt;/li&gt;
  &lt;li&gt;「media query」声明的CSS是不会阻塞渲染的&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;遇到js脚本资源&quot;&gt;遇到JS脚本资源&lt;/h3&gt;
&lt;p&gt;JS脚本资源的处理有几个特点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会解析HTML&lt;/li&gt;
  &lt;li&gt;浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其他资源（当然也有并发上限），但是虽然脚本可以并行下载，但是解析过程仍然是阻塞的，也即是说必须这个脚本和执行完成后才能继续解析，并行下载只是一个优化操作&lt;/li&gt;
  &lt;li&gt;defer与async，普通德积小本是会阻塞浏览器解析的，但是可以加上defer或者async属性，这样脚本就会变成异步了，可以等待解析结束后执行脚本。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;值得注意的是，defer是延迟执行，async是异步执行&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单的来说：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;「async」是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在onload钱，但是不确定在「DOMContentLoaded」事件的前或者后&lt;/li&gt;
  &lt;li&gt;「defer」是延迟执行，在浏览器看起来的效果像是将脚本放在body后面一样。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;domcontentloaded事件和onload事件的区别&quot;&gt;DOMContentLoaded事件和onload事件的区别&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DOMContentLoaded: 当初始的HTML文档被完全加载和解析后，被触发，无需等待样式表、图像和子框架的加载完成。
onload:仅用于检测一个完全加载的页面（图像、CSS资源等）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;遇到img图片类资源&quot;&gt;遇到img图片类资源&lt;/h4&gt;

&lt;p&gt;遇到图片资源时候，直接是异步下载，不会阻塞解析，下载完成后直接使用图片替换原有SRC&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;html基本整理好了，明天和同事有个聚会，就暂时偷个懒，下周开始整理CSS&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 21 Feb 2019 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/21/%E8%A7%A3%E6%9E%90%E9%A1%B5%E9%9D%A2%E6%B5%81%E7%A8%8B-3-HTML%E5%88%9D%E5%A7%8B%E5%8C%96%E9%81%87%E5%88%B0%E5%A4%96%E9%93%BE%E7%9A%84%E5%A4%84%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/21/%E8%A7%A3%E6%9E%90%E9%A1%B5%E9%9D%A2%E6%B5%81%E7%A8%8B-3-HTML%E5%88%9D%E5%A7%8B%E5%8C%96%E9%81%87%E5%88%B0%E5%A4%96%E9%93%BE%E7%9A%84%E5%A4%84%E7%90%86/</guid>
        
        <category>笔记</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>2019-02-20 解析页面流程（2）生成CSS规则和构建渲染</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#生成css规则&quot; id=&quot;markdown-toc-生成css规则&quot;&gt;生成CSS规则&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#举个例子&quot; id=&quot;markdown-toc-举个例子&quot;&gt;举个例子&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#css代码&quot; id=&quot;markdown-toc-css代码&quot;&gt;CSS代码&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#dom树&quot; id=&quot;markdown-toc-dom树&quot;&gt;DOM树：&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#构建渲染书&quot; id=&quot;markdown-toc-构建渲染书&quot;&gt;构建渲染书&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#渲染&quot; id=&quot;markdown-toc-渲染&quot;&gt;渲染&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#什么是回流&quot; id=&quot;markdown-toc-什么是回流&quot;&gt;什么是回流?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#什么是重绘&quot; id=&quot;markdown-toc-什么是重绘&quot;&gt;什么是重绘？&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#什么会引起回流&quot; id=&quot;markdown-toc-什么会引起回流&quot;&gt;什么会引起回流？&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#回流优化方案&quot; id=&quot;markdown-toc-回流优化方案&quot;&gt;回流优化方案&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#简单层与复杂层&quot; id=&quot;markdown-toc-简单层与复杂层&quot;&gt;简单层与复杂层&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;生成css规则&quot;&gt;生成CSS规则&lt;/h2&gt;
&lt;p&gt;同理，CSS规则树的生成也是类似&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Bytes -&amp;gt; character -&amp;gt; tokens -&amp;gt; nodes -&amp;gt; CSSOM
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.Conversion：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符
2.Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都他有自己独特的含义以及规则及
3.Lexing词法分析：分词的结果是得到了堆的token，此时把他们的转换为对象，这些对象分别定义了他们的属性和规则
4.DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;举个例子&quot;&gt;举个例子&lt;/h3&gt;
&lt;h4 id=&quot;css代码&quot;&gt;CSS代码&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;body { font-size: 16px }
p { font-weight: bold }
span { color: red }
p span { display: none }
img { float: right }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;dom树&quot;&gt;DOM树：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1g0csljk8rsj30g608bq38.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;构建渲染书&quot;&gt;构建渲染书&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;现在「CSS树」和「DOM树」都已经完成，浏览器现在要开始构建渲染树了。
一般情况，「渲染树」和「DOM树」相对应的， 但是也不定，因为有些不可见的（display:none;）等等不可见的标签会影响「渲染树」
&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1g0cspjnnvqj30p00bo0ti.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;渲染&quot;&gt;渲染&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;有了渲染书（render），开始渲染：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcgy1g0csqsdknsj30m8064q3c.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分为四个步骤:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.计算CSS样式
2.构建渲染书
3.布局，主要定位坐标的和大小，是否换行，各种position overflow z-index 属性
4.绘制，将图像绘制出来
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然后，图中的线与箭头表示通过JS动态修改了DOM或者CSS，会导致页面「重新布局（Layout）」、「渲染（Repaint）」&lt;/p&gt;

&lt;h3 id=&quot;什么是回流&quot;&gt;什么是回流?&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Layout,也叫Reflow。html的内容。结构、位置或尺寸发送了变化，需要重新计划样式和渲染树&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;什么是重绘&quot;&gt;什么是重绘？&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Repaint。元素发生的改变只是影响了元素本身的一些外观之类的（背景，边框颜色等），此时只需要应用新样式绘制这个元素就可以了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;回流的成本开销&amp;gt;重绘的成本开销，而且一个节点的回流往往导致子节点以及同级节点的回流。&lt;/p&gt;

&lt;h3 id=&quot;什么会引起回流&quot;&gt;什么会引起回流？&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.页面渲染初始化
2.DOM结构改变，比如删除了某个节点
3.render树变化，比如减少了padding
4.窗口resize
5.获取某些属性
6.改变字体大小
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;很多浏览器会对回流做优化，会等到数量足够是做一次批处理回流，
但是处理render树的直接变化，当获取一些属性的时候，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    1.offset（Top/Left/Width/Height）
    2.scroll（Top/Left/Width/Height）
    3.cilent（Top/Left/Width/Height）
    4.width,height
    5.调用了getComputedStyle()/IE的currentStyle
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;回流优化方案&quot;&gt;回流优化方案&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;减少逐项更改样式，最好一次性更改style，或者将样式定义为Class并一次性更新&lt;/li&gt;
  &lt;li&gt;避免循环操作dom，创建一个documentFragment或者div，在它上面应用所以DOM操作，最后把它添加到window.document上&lt;/li&gt;
  &lt;li&gt;避免多次读取offest等属性。无法避免则将他们缓存为变量。&lt;/li&gt;
  &lt;li&gt;将复杂的元素绝对定位或者固定定位，使得他们脱离文档流，否则回流代价会很高&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var s = document.body.style;

s.padding = &quot;2px&quot;; // 回流+重绘
s.border = &quot;1px solid red&quot;; // 再一次 回流+重绘
s.color = &quot;blue&quot;; // 再一次重绘
s.backgroundColor = &quot;#ccc&quot;; // 再一次 重绘
s.fontSize = &quot;14px&quot;; // 再一次 回流+重绘
// 添加node，再一次 回流+重绘
document.body.appendChild(document.createTextNode('abc!'));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;简单层与复杂层&quot;&gt;简单层与复杂层&lt;/h3&gt;
&lt;p&gt;上述中的渲染中止步于绘制，但实际上绘制这一步，需要从简单层和复杂层来讲。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;可以默认只有一个复合图层，所有的DOM节点都在这个图层上面，&lt;/li&gt;
  &lt;li&gt;如果开启了硬件加速功能，可以将某个节点转为复合图层&lt;/li&gt;
  &lt;li&gt;复合涂层之间的绘制互不干扰，由GPU控制&lt;/li&gt;
  &lt;li&gt;而简单图层中，就算是absolute等布局，变化的时候不影响整体的回流，但是由于在同一个图层中，仍然是会影响绘制的，因此做动画的时候性能仍然很低，而复合图层是独立的，所以一般动画推荐使用硬件加速。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 20 Feb 2019 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/20/%E8%A7%A3%E6%9E%90%E9%A1%B5%E9%9D%A2%E6%B5%81%E7%A8%8B-2-%E7%94%9F%E6%88%90CSS%E8%A7%84%E5%88%99%E5%92%8C%E6%9E%84%E5%BB%BA%E6%B8%B2%E6%9F%93/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/20/%E8%A7%A3%E6%9E%90%E9%A1%B5%E9%9D%A2%E6%B5%81%E7%A8%8B-2-%E7%94%9F%E6%88%90CSS%E8%A7%84%E5%88%99%E5%92%8C%E6%9E%84%E5%BB%BA%E6%B8%B2%E6%9F%93/</guid>
        
        <category>笔记</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>2019-02-19 解析页面流程(1) 解析HTML，构建DOM树</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#总体流程&quot; id=&quot;markdown-toc-总体流程&quot;&gt;总体流程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#解析html构建dom树&quot; id=&quot;markdown-toc-解析html构建dom树&quot;&gt;解析HTML，构建DOM树&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#浏览器处理流程大概是这个样子&quot; id=&quot;markdown-toc-浏览器处理流程大概是这个样子&quot;&gt;浏览器处理流程大概是这个样子&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#浏览器处理示意图&quot; id=&quot;markdown-toc-浏览器处理示意图&quot;&gt;浏览器处理示意图：&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#形成dom树&quot; id=&quot;markdown-toc-形成dom树&quot;&gt;形成DOM树：&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#结语&quot; id=&quot;markdown-toc-结语&quot;&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;http请求完成，浏览器获取到了html，开始解析并且渲染HTML&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;总体流程&quot;&gt;总体流程&lt;/h3&gt;

&lt;p&gt;浏览器内核拿到内容后，渲染步骤：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.解析HTML，构建DOM树
2.解析CSS，生成CSS规则树
3.合并DOM树和CSS规则，生成render树
4.布局render树（Layout/reflow），负责各元素尺寸、位置的计算
5.绘制render数据（paint），绘制页面像素信息
6.浏览器会将各层的信息发送给GPU,GPU会将各层合成（composite），显示在屏幕上
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1g0c03h0oqqj30p009sq33.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;解析html构建dom树&quot;&gt;解析HTML，构建DOM树&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;这是渲染流程第一步，浏览器将解析HTML，构建成DOM树，&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;流程：Bytes  -&amp;gt;  characters -&amp;gt;  tokens   -&amp;gt;  node  -&amp;gt;  DOM
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;viewport&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;width=device-width,initial-scale=1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;style.css&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Critical Path&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;Hello &lt;span class=&quot;nt&quot;&gt;&amp;lt;span&amp;gt;&lt;/span&gt;web performance&lt;span class=&quot;nt&quot;&gt;&amp;lt;/span&amp;gt;&lt;/span&gt; students!&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&amp;gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;awesome-photo.jpg&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;浏览器处理流程大概是这个样子&quot;&gt;浏览器处理流程大概是这个样子&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.Conversion转换 -&amp;gt;  数据字节流（HTML内容Btyes）基于他的编码生成单个字符
2.Tokenizing分词  -&amp;gt;  由数据字节按浏览器HTML规范标准版生成标签、内容（标记TOKEN），每个TOKEN有他自己的定义和规则集
3.Lexing词法分析 -&amp;gt;  由白标签、内容成Token，此时把它们转换为对象，这些对象分别定义了他们的属性和4规则（header/p/span）
4.DOM构建-&amp;gt;  开始构建由不同的html标签的关系来渲染父-&amp;gt;子结构的树状结构。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;浏览器处理示意图&quot;&gt;浏览器处理示意图：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1g0c06x3e19j30p00du3zh.jpg&quot; alt=&quot;iamge&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;形成dom树&quot;&gt;形成DOM树：&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcgy1g0c083cudtj30ih07wq36.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;今天的内容比较少，一是最近工作挺多的，二是今天家里换了200M的网（免费的~~~~~~~ 开心~~~~~），突然发现原先的路由器「小米路由器3」和「小米电力猫」、交换机均不支持200M的速率，LAN和WAN端口支持100M，so要花点时间挑选一个性价比高的路由器的电力猫。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcgy1g0c0foevnhj30hs0gyq3u.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Feb 2019 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/19/%E8%A7%A3%E6%9E%90%E9%A1%B5%E9%9D%A2%E6%B5%81%E7%A8%8B-1-%E8%A7%A3%E6%9E%90HTML-%E6%9E%84%E5%BB%BADOM%E6%A0%91/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/19/%E8%A7%A3%E6%9E%90%E9%A1%B5%E9%9D%A2%E6%B5%81%E7%A8%8B-1-%E8%A7%A3%E6%9E%90HTML-%E6%9E%84%E5%BB%BADOM%E6%A0%91/</guid>
        
        <category>笔记</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>Http2.0、https（2）</title>
        <description>
&lt;hr /&gt;
&lt;p&gt;layout: post
title:  “2019-02-18-http2.0、https（2）”
date:    2019-02-18 21:00:00 +0800
categories: 前端
tag: 笔记
—&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#头部的区别&quot; id=&quot;markdown-toc-头部的区别&quot;&gt;头部的区别&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#max-age与expires的区别&quot; id=&quot;markdown-toc-max-age与expires的区别&quot;&gt;Max-Age与Expires的区别&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#ps同时启动了cache-control与expirescache-contrl优先级更高&quot; id=&quot;markdown-toc-ps同时启动了cache-control与expirescache-contrl优先级更高&quot;&gt;PS：同时启动了Cache-Control与Expires，Cache-Contrl优先级更高。&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#e-tag和last-modified的区别&quot; id=&quot;markdown-toc-e-tag和last-modified的区别&quot;&gt;E-tag和Last-Modified的区别&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#图解&quot; id=&quot;markdown-toc-图解&quot;&gt;图解&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#结语&quot; id=&quot;markdown-toc-结语&quot;&gt;结语&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;头部的区别&quot;&gt;头部的区别&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;从http1.0到http1.1，改进了很多头部&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;http1.0的缓存控制：
    &lt;ul&gt;
      &lt;li&gt;Pragma：严格来说，它不属于专门的缓存控制头，但是它设置了「no-cache」可以让本地强缓存失效（相当于一个配置项）&lt;/li&gt;
      &lt;li&gt;Expires：服务器配置，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如Expires：Fri，30 Oct 2001 12:22:12&lt;/li&gt;
      &lt;li&gt;If-Modifien-Since/Last-Modifed:这个、两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是「If-Modified-Since」，而服务端的是「Last-Modified」，他的作用是，在发起请求时，如果「If-Modified-Since」和「Last-Modified」匹配， 那么代表服务器资源并未改变，因此服务器不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。「Last-Modified」-&amp;gt; 文件最后修改的时间，只能精确到1s&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;http1.1的缓存控制：
    &lt;ul&gt;
      &lt;li&gt;Cache-Control：缓存控制头部，有no-cache、max-age等多种取值。&lt;/li&gt;
      &lt;li&gt;Max-Age： 服务器配置的，用来控制强缓存，在规定的时间之内，浏览器无需发送请求，直接使用本地缓存，注意「Max-Age」是「Cache-Control」的值，不是独立的头部，例如「Cache-Control:max-age=3600」,而且它的值是绝对时间，由服务器计算&lt;/li&gt;
      &lt;li&gt;If-None-Match/E-tag:这两个是成对出现的，属于协商缓存的内容，其实浏览器头部的是「If-None-Match」，而服务端的是「E-tag」，同样，发出请求后， 如果「If-None-Match」和「E-tag」匹配，则代表内容未变，通知浏览器使用本地缓存，和「Last-Modified」不同，「E-tag」更精确，它是类似于指纹一样的东西，基于「FileEtag INode Mtime Size」生成的，也是只要文件变，指纹就会变，而且没有任何精度限制&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;max-age与expires的区别&quot;&gt;Max-Age与Expires的区别&lt;/h3&gt;
&lt;p&gt;「Expires」使用的是服务器端的本地时间，但是有时客户端时间好服务器端时间不同步，导致了浏览器本地的缓存失效或者过期&lt;/p&gt;

&lt;p&gt;所以不推荐Expires，而且Max-Age使用的是客户端本地时间计算，所以不会有这个问题，所以推荐使用Max-Age&lt;/p&gt;

&lt;h4 id=&quot;ps同时启动了cache-control与expirescache-contrl优先级更高&quot;&gt;PS：同时启动了Cache-Control与Expires，Cache-Contrl优先级更高。&lt;/h4&gt;

&lt;h3 id=&quot;e-tag和last-modified的区别&quot;&gt;E-tag和Last-Modified的区别&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Last-Modified:
    &lt;ul&gt;
      &lt;li&gt;表明服务器端的文件时最后何时改变的&lt;/li&gt;
      &lt;li&gt;缺点：只能精确到1s&lt;/li&gt;
      &lt;li&gt;服务端的文件会周期性改变，导致缓存失效&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;E-tag：
    &lt;ul&gt;
      &lt;li&gt;是一种种指纹机制，可以代表文件的相关唯一性&lt;/li&gt;
      &lt;li&gt;只有文件改变，缓存才会变&lt;/li&gt;
      &lt;li&gt;没有精确时间的限定&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;图解&quot;&gt;图解&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcgy1g0atbc7vpfj30m80djq34.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;第一步，HTTP请求终于讲完了，其实我之前对整个请求体系基本不知道多少。明天开始我会开始整理（抄）解析页面流程，敬请期待！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 18 Feb 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/18/http2.0-https-2/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/18/http2.0-https-2/</guid>
        
        
      </item>
    
  </channel>
</rss>
