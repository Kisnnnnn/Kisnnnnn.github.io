<!DOCTYPE html>
<html>

  <head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>浏览器如何发起一个完整的HTTP请求(2) - 翻山越岭遇到一条狗的Blog</title>

	<link rel="shortcut icon" href="/styles/images/favicon.jpg">
	<link rel="icon" href="/styles/images/favicon.jpg">

	<link rel="stylesheet" href="/styles/css/index.css">
	<link rel="stylesheet" href="/styles/css/fontawesome/css/font-awesome.min.css">
	<link rel="stylesheet" href="/styles/css/syntax.css">
	<link rel="canonical" href="/2019/02/15/http(2)/">
	<link rel="alternate" type="application/rss+xml" title="翻山越岭遇到一条狗的Blog" href="/feed.xml">
	
	<meta name="keywords" content="浏览器如何发起一个完整的HTTP请求(2), 翻山越岭遇到一条狗的Blog, 袁凯忻;个人博客;前端技术;">
	<meta name="description" content="袁凯忻;个人博客;前端技术;">

	<script src="/styles/js/jquery.min.js"></script>
	<!--[if lt IE 9]>
    	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  	<![endif]-->
  	<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?";
		  var s = document.getElementsByTagName("script")[0]; 
		  s.parentNode.insertBefore(hm, s);
		})();
	</script>
  	<style type="text/css">
	  	.docs-content{
	  		margin-bottom: 10px;
	  	}
  	</style>
</head>

  <body class="index">

    <header class="navbar navbar-inverse navbar-fixed-top docs-nav" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <!-- <a href="/" class="navbar-brand">
        <img src="/styles/images/logo.jpg">
      </a> -->
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
      <ul class="nav navbar-nav">
        <li>
          <a href="/">Home</a>
        </li>
        <li>
          <a href="/categories/">Categories</a>
        </li>
        <li>
          <a href="/tag">Tag</a>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
          <!-- <a><span id="busuanzi_container_site_pv" style="display:non">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></a> -->
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown">关于<b class="caret"></b></a>
          <ul class="dropdown-menu">
            <li><a rel="nofollow" target="_blank" href="https://github.com/Kisnnnnn/">Github</a></li>
            <li><a rel="nofollow" target="_blank" href="https://kisnnnnn.github.io/kisnStudy/">关于作者</a></li>
            <li><a rel="nofollow" href="/books">我的书单</a></li>
            <li><a rel="nofollow" href="/reference">推荐博客</a></li>
          </ul>
        </li>
      </ul>
    </nav>
  </div>
</header>
    <div class="docs-header" id="content">
  <div class="container">
  	
  		<!--
		    <h1>浏览器如何发起一个完整的HTTP请求(2)</h1>
		    <p>Post on Feb 15, 2019 by <a href="/about">Kisn</a></p>
		-->
		    <h1>「今でもあなたはわたしの光」</h1>
    
  </div>
</div>
    
      
<div class="banner">
  <div class="container">
  	
    	<a href="/categories/#前端-ref">前端</a>	/
    	<a href="/tag/#笔记-ref">笔记</a>
    
  </div>
</div>

    

    <!-- <script src=""></script> -->
<div class="container docs-container">
  <div class="row">
    <div class="col-md-3">
      <div class="sidebar hidden-print" role="complementary">
        <div id="navigation">
    <h1>目录</h1>
    <ul class="nav sidenav">
    </ul>
    <!-- <div style="height: 200px;width: 200px;">
      <script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=&amp;m=0&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33" async="async"> 
      </script>
    </div> -->
  </div>
  
   
      </div>
    </div>
    <div class="col-md-9" role="main">
      <div class="panel docs-content">
        <div class="wrapper">
            <header class="post-header">
              <h1 class="post-title">浏览器如何发起一个完整的HTTP请求(2)</h1>
              <!--
                <p class="post-meta">Feb 15, 2019</p>
              -->
              <div class="meta">Posted on <span class="postdate">Feb 15, 2019</span> By <a target="_blank" href="http://localhost:4000">Kisn</a></div>
              <br />
            </header>
            <article class="post-content">
              <ul id="markdown-toc">
  <li><a href="#常用的请求头部" id="markdown-toc-常用的请求头部">常用的请求头部</a>    <ul>
      <li><a href="#accept-和-content-type-的区别" id="markdown-toc-accept-和-content-type-的区别">Accept 和 Content-Type 的区别</a></li>
    </ul>
  </li>
  <li><a href="#常用的响应头" id="markdown-toc-常用的响应头">常用的响应头</a>    <ul>
      <li><a href="#其实我在整理之前一直在想为什么请求头部也有content-type那为什么不是它和响应头部的content-type匹配" id="markdown-toc-其实我在整理之前一直在想为什么请求头部也有content-type那为什么不是它和响应头部的content-type匹配">其实我在整理之前一直在想为什么请求头部也有「Content-Type」，那为什么不是它和响应头部的「Content-Type」匹配？</a></li>
      <li><a href="#举栗子" id="markdown-toc-举栗子">举栗子</a></li>
      <li><a href="#什么是实体头" id="markdown-toc-什么是实体头">什么是实体头？</a></li>
      <li><a href="#什么是实体信息" id="markdown-toc-什么是实体信息">什么是实体信息？</a></li>
      <li><a href="#最后讲一下crlf" id="markdown-toc-最后讲一下crlf">最后讲一下，CRLF</a></li>
      <li><a href="#http请求报文结构栗子" id="markdown-toc-http请求报文结构栗子">http请求报文结构栗子：</a>        <ul>
          <li><a href="#再说点什么" id="markdown-toc-再说点什么">再说点什么？</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>昨天看到请求头部分，整理一些通用请求头，下面整理下常用的响应/请求头</p>
</blockquote>

<h2 id="常用的请求头部">常用的请求头部</h2>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1g07d0evn94j30h807u3yq.jpg" alt="image" /></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Accept：接受类型，标示浏览器支持的MIME类型（对标服务器返回的Centent-Type）
Accept-Encoding： 浏览器支持的压缩类型，比如gzip等，超过类型不能接受
Content-Type：客户端发送出去实体内容的类型
Cache-Control：指定请求和响应遵循的缓存机制，如no-cache、no-store
If-Modified-Since：对应服务器的Last-Modified,用来匹配看文件是否变动，精确到1s
Expires：缓存控制，在这个时间内不会请求，直接使用缓存（http1.0，而且是服务器端时间）
Max-age： 代表资源在本地缓存多少秒，有效时间不会请求，而是使用缓存（http1.1）
If-None-Match：对于服务端的ETag，用于匹配文件内容是否改变（非常精确）（http1.1）
Cookie：有cookie并且同域访问时会自动带上（www.baidu.com/a.baidu.com非同域名！）
Host：请求的服务器URL
Origin：最初请求是从哪里发起的（精确到端口），Origin比Referer更遵循隐私
Referer：该页面的来源URL（适用于所有类型的请求，会精确到详细页面，csrf通常会拦截该字段）
User-Agent：用户客户端的一些必要信息
</code></pre></div></div>
<p><strong>备注</strong></p>

<blockquote>
  <p>no-cache:可以在本地缓存，可以代理服务器缓存，但是和这个缓存需要服务器验证以后才可以使用</p>
</blockquote>

<blockquote>
  <p>no-store:禁用缓存，本地和代理服务器均不准使用,必须从服务器获取</p>
</blockquote>

<h3 id="accept-和-content-type-的区别">Accept 和 Content-Type 的区别</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Accpet属于请求头，Content-Type属于实体头
Accpet：告诉服务端，客户端接收什么类型的信息
Content-Type：发送端（客户端|服务器端）发送的实体数据的数据类型
</code></pre></div></div>

<h2 id="常用的响应头">常用的响应头</h2>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g07d2tzlz5j30gq08zglu.jpg" alt="image" /></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Access-Control-Allow-Hedaers：服务器端允许的Headers
Access-Control-Allow-Methods：服务器端允许的请求方法
Acees-Control-Allow-Origin：服务器端允许的请求Origin头部
Content-Type：服务器返回的实体内容类型
Data：数据从服务器发起的时间
Cache-Control：告诉浏览器或其他用户，什么环境可以安全的缓存文档
Last-Modified：请求资源的最后修改时间
Expires：文档的过期时间，删除缓存
Max-age：客户端的本地资源的缓存时间(单位-秒)，开启了Cache-Contral后有效
ETag：请求标量的实体标签的当前值
Set-Cookie：设置和页面关联的cookie，服务器通过整个头部把cookie传给客户端
Keep-Alive：客户端有keep-alive，服务端也会响应（timeout=38）
Server：服务器的一些相关信息
</code></pre></div></div>
<p>请求头部和响应头部是彼此匹配分析的。</p>

<p>最常见的：
请求头部的Accept要和响应头部的Content-Type进行匹配，否则会报错。</p>
<h4 id="其实我在整理之前一直在想为什么请求头部也有content-type那为什么不是它和响应头部的content-type匹配">其实我在整理之前一直在想为什么请求头部也有「Content-Type」，那为什么不是它和响应头部的「Content-Type」匹配？</h4>
<p>后来，我整理的时候发现，「Content-Type」是实体头部，指的是：「发送端（可以使客户端，也可以是服务端），用来表明发送信息的文档类型的」，也就是说他是发送性质的，「Accept」是接受性质，so请求头部的「Accept」和响应头部的「Cotent-Type」匹配的。</p>

<h4 id="举栗子">举栗子</h4>
<p>造成跨域问题，往往是因为请求头部「Origin」要匹配响应头部的「Access-Control-Allow-Origin」，一旦匹配失败，则会报跨域错误。</p>

<p>在使用缓存时，请求头部的If-Modified-Since、If-None-Match分别和响应头部的Last-Modified、ETag对应</p>

<h3 id="什么是实体头">什么是实体头？</h3>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1g07d19zojoj30h00abmxi.jpg" alt="image" /></p>

<blockquote>
  <p>可以理解为「实体信息」的头部</p>
</blockquote>

<h3 id="什么是实体信息">什么是实体信息？</h3>

<blockquote>
  <p>消息实体分为响应实体、请求实体</p>
</blockquote>

<p>在http请求中，会将一些需要的参数放入，你比如POST请求。</p>

<p>实体信息中可以放入参数（data=ab&amp;query=123），也可以直接通过表单对象（Form Data对象，上传时可以带参数、文件、二进制流）</p>

<p>而http响应时候，服务端就会返回实体信息（没错，就是reponse）</p>

<p>一般的接口请求，实体信息就是JSON格式的数据，然而接口返回的可以使JSON格式的数据也可以使html，然后通过JS渲染</p>

<h3 id="最后讲一下crlf">最后讲一下，CRLF</h3>

<blockquote>
  <p>Carriage-Return Line-Feed), 回车换行符</p>
</blockquote>

<p>（我也不明白这东西有什么用）</p>

<p>请求头和实体消息之间有一个CRLF分隔，响应头部和响应实体之间用一个CRLF分隔</p>

<p>一般来说（分隔符类别）:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CRLF-&gt;Windows-style
LF-&gt;Unix Style
CR-&gt;Mac Style
</code></pre></div></div>
<p>结束下面附上一个http请求栗子</p>

<h3 id="http请求报文结构栗子">http请求报文结构栗子：</h3>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1g07e2c2i61j30gk0m80uo.jpg" alt="image" /></p>

<h4 id="再说点什么">再说点什么？</h4>

<blockquote>
  <p>今天的内容其实我已经整理的差不多，两天把大牛的http请求，简单的整理（抄）了一遍，收获很多，之前一直不懂跨域的原理，以及request/response的头部匹配，基本也理解了。从HTTP报文结构表面来看至少看出来跨域的问题来自哪里，具体如何解决还需要仔细研究</p>
</blockquote>

<p>2019年02月15日20:40:48
袁凯忻</p>

            </article>
        </div>
      </div>
    </div>
  </div>
</div>

    
    <footer class="footer" role="contentinfo">
	<div class="container">
		<p class="copyright">Copyright &copy; 2014-2019 <a href="https://kisnnnnn.github.io/kisnStudy/"><code>Kisn</code></a>.</p>
		<!-- <p>Powered by <a href="http://jekyllrb.com">Jekyll</a>, themed from <a href="http://lesscss.cn/">Less</a>, refactored by <a href="http://www.hifreud.com/">Freud Kang</a></p> -->
	</div>
</footer>

<script src="/styles/js/jquery.min.js"></script>
<script src="/styles/js/bootstrap.min.js"></script>
<script src="/styles/js/holder.min.js"></script>
<script src="/styles/js/lessismore.js"></script>
<script src="/styles/js/application.js"></script>
<script src="/styles/js/jquery.zoom.min.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script>
	(function ($) {
		window.onload = function () {
			var imgELemList = $('.container img');

			imgELemList.on('click', function () {
				console.log(imgELemList);

				window.location.href = this.src;
			});
		}
	})(jQuery)
</script>

  </body>
</html>
